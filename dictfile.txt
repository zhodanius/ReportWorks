alive\rrlite\framewrk\autoobj.cpp:        ITypeInfo *pTypeInfoTmp;
alive\rrlite\framewrk\autoobj.cpp:        hr = pTypeLib->GetTypeInfoOfGuid((REFIID)INTERFACEOFOBJECT(m_ObjectType), &pTypeInfoTmp);
alive\rrlite\framewrk\autoobj.cpp:        hr = pTypeInfoTmp->GetRefTypeOfImplType(0xffffffff, &hrefType);
alive\rrlite\framewrk\autoobj.cpp:            pTypeInfoTmp->Release();
alive\rrlite\framewrk\autoobj.cpp:        hr = pTypeInfoTmp->GetRefTypeInfo(hrefType, ppTypeInfo);
alive\rrlite\framewrk\autoobj.cpp:        pTypeInfoTmp->Release();
alive\rrlite\framewrk\autoobj.cpp:    WCHAR   wszTmp[256];
alive\rrlite\framewrk\autoobj.cpp:    char    szTmp[256];
alive\rrlite\framewrk\autoobj.cpp:    LoadString(GetResourceHandle(), idException, szTmp, 256);
alive\rrlite\framewrk\autoobj.cpp:    MultiByteToWideChar(CP_ACP, 0, szTmp, -1, wszTmp, 256);
alive\rrlite\framewrk\autoobj.cpp:    pCreateErrorInfo->SetDescription(wszTmp);
alive\rrlite\framewrk\autoobj.cpp:    MultiByteToWideChar(CP_ACP, 0, NAMEOFOBJECT(m_ObjectType), -1, wszTmp, 256);
alive\rrlite\framewrk\autoobj.cpp:    pCreateErrorInfo->SetSource(wszTmp);
alive\rrlite\framewrk\autoobj.cpp:// indicates whether or not the given interface supports rich error information
alive\rrlite\framewrk\ctlembed.cpp://    DWORD             - [in] indicates whether to save the object before closing
alive\rrlite\framewrk\ctlembed.cpp:// Returns a value indicating the status of an object at creation and loading.
alive\rrlite\framewrk\ctlembed.cpp:// Indicates how much of the control is visible.
alive\rrlite\framewrk\ctlocx96.cpp:// indicates to an inactive oobject that the mouse pointer has moved over the
alive\rrlite\framewrk\ctlview.cpp:    // depending on the flag in the CONTROLOBJECTINFO structure, indicate our
alive\rrlite\framewrk\ctlview.cpp:    // override this routine and return, in addition to the flags indication
alive\rrlite\framewrk\ctlview.cpp:    // opacity, flags indicating what sort of drawing aspects they support.
alive\rrlite\framewrk\ctlview.cpp:// indicates whether a point is within a given aspect of an object.
alive\rrlite\framewrk\ctlview.cpp:// indicates wheter any point in a rectangle is within a given drawing aspect
alive\rrlite\framewrk\ctlwrap.cpp:// indicates whether or not we have the focus.
alive\rrlite\framewrk\ipserver.cpp:    char    szTmp[MAX_PATH];
alive\rrlite\framewrk\ipserver.cpp:        dwPathLen = GetModuleFileName(g_hInstance, szTmp, MAX_PATH);
alive\rrlite\framewrk\ipserver.cpp:        MAKE_WIDEPTR_FROMANSI(pwsz, szTmp);
alive\rrlite\framewrk\util.cpp:    char szTmp[512];
alive\rrlite\framewrk\util.cpp:    i = LoadString(GetResourceHandle(), wId, szTmp, 512);
alive\rrlite\framewrk\util.cpp:    return MakeWideStrFromAnsi(szTmp, bType);
alive\rrlite\framewrk\util.cpp:    LPWSTR pwszTmp;
alive\rrlite\framewrk\util.cpp:        pwszTmp = (LPWSTR)CoTaskMemAlloc((i * sizeof(WCHAR)) + sizeof(WCHAR));
alive\rrlite\framewrk\util.cpp:        if (!pwszTmp) return NULL;
alive\rrlite\framewrk\util.cpp:        memcpy(pwszTmp, pwsz, (sizeof(WCHAR) * i) + sizeof(WCHAR));
alive\rrlite\framewrk\util.cpp:        pwszTmp = (LPWSTR)SysAllocString(pwsz);
alive\rrlite\framewrk\util.cpp:    return pwszTmp;
alive\rrlite\framewrk\util.cpp:    char    szTmp[MAX_PATH];
alive\rrlite\framewrk\util.cpp:    wsprintf(szTmp, "CLSID\\%s", szGuidStr);
alive\rrlite\framewrk\util.cpp:    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, szTmp, 0, KEY_ALL_ACCESS, &hk);
alive\rrlite\framewrk\util.cpp:    szTmp[0] = '0';
alive\rrlite\framewrk\util.cpp:    szTmp[1] = '\0';
alive\rrlite\framewrk\util.cpp:    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szTmp, 2);
alive\rrlite\framewrk\util.cpp:    wsprintf(szTmp, "%d", dwMiscStatus);
alive\rrlite\framewrk\util.cpp:    l = RegSetValueEx(hkSub2, NULL, 0, REG_SZ, (BYTE *)szTmp, lstrlen(szTmp) + 1);
alive\rrlite\framewrk\util.cpp:    GetModuleFileName(g_hInstance, szTmp, MAX_PATH);
alive\rrlite\framewrk\util.cpp:    lstrcat(szTmp, szGuidStr);
alive\rrlite\framewrk\util.cpp:    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szTmp, lstrlen(szTmp) + 1);
alive\rrlite\framewrk\util.cpp:    wsprintf(szTmp, "%ld.0", lVersion);
alive\rrlite\framewrk\util.cpp:    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szTmp, lstrlen(szTmp) + 1);
alive\rrlite\framewrk\util.cpp:    char  szTmp[MAX_PATH];
alive\rrlite\framewrk\util.cpp:    DWORD dwTmpSize;
alive\rrlite\framewrk\util.cpp:        dwTmpSize = MAX_PATH;
alive\rrlite\framewrk\util.cpp:        l = RegEnumKeyEx(hk, x, szTmp, &dwTmpSize, 0, NULL, NULL, NULL);
alive\rrlite\framewrk\util.cpp:        f = DeleteKeyAndSubKeys(hk, szTmp);
alive\rrlite\framewrk\util.cpp:    char szExtension[5], szTmp[MAX_PATH];
alive\rrlite\framewrk\util.cpp:    i = LoadString(g_hInstance, 1001, szTmp, sizeof(szTmp));
alive\rrlite\framewrk\util.cpp:    wsprintf(szDllName, "%s%s.DLL", szTmp, szExtension);
alive\rrlite\framewrk\util.cpp:    GetModuleFileName(g_hInstance, szTmp, MAX_PATH);
alive\rrlite\framewrk\util.cpp:    _MakePath(szTmp, szDllName, szFinalName);
alive\rrlite\rrvwctrl.cpp:	{ // create progress indicator
alive\rrlite\rrvwctrl.cpp:    // indicate that here.  never forget to call COleControl's version in the
alive\rrlite\rrvwctrl.cpp:			// just flash to indicate we're keyboard ready
alive\rrlite\viewtext.cpp:		showEndOfPage();	// indicate end of page
allfiles.cpp:05/07/2010  04:44 PM    <DIR>          DATADICT
allfiles.cpp: Directory of K:\RR\DATADICT
allfiles.cpp:08/21/2009  11:02 AM            70,474 datadict.cpp
allfiles.cpp:06/26/2006  10:19 AM    <DIR>          DataDict
allfiles.cpp: Directory of K:\RR\External\DataDict
allfiles.cpp:06/26/2006  09:54 AM           732,968 datadict.exe
allfiles.cpp:06/26/2006  09:55 AM             7,680 dictfld.CDX
allfiles.cpp:06/26/2006  09:55 AM               936 dictfld.DBF
allfiles.cpp:06/26/2006  09:55 AM               512 dictfld.FPT
allfiles.cpp:06/26/2006  09:55 AM             5,632 dictindx.CDX
allfiles.cpp:06/26/2006  09:55 AM             9,417 dictindx.DBF
allfiles.cpp:06/26/2006  09:55 AM               896 dictindx.FPT
allfiles.cpp:06/26/2006  09:55 AM            11,776 dicttabl.CDX
allfiles.cpp:06/26/2006  09:55 AM            21,487 dicttabl.DBF
allfiles.cpp:06/26/2006  09:55 AM               768 dicttabl.FPT
allfiles.cpp:06/26/2006  09:55 AM            24,064 FldDict.RRW
allfiles.cpp:06/26/2006  09:55 AM               726 ownertmp.DBF
allfiles.cpp:06/26/2006  09:55 AM            21,504 TblDict.RRW
allfiles.cpp:06/26/2006  09:55 AM         1,097,022 datadict.exe
allfiles.cpp:06/26/2006  09:55 AM            10,752 dictfld.CDX
allfiles.cpp:06/26/2006  09:55 AM               936 dictfld.DBF
allfiles.cpp:06/26/2006  09:55 AM               512 dictfld.FPT
allfiles.cpp:06/26/2006  09:55 AM             4,608 dictindx.CDX
allfiles.cpp:06/26/2006  09:55 AM               616 dictindx.DBF
allfiles.cpp:06/26/2006  09:55 AM               512 dictindx.FPT
allfiles.cpp:06/26/2006  09:55 AM         3,681,669 Dictionary Help.PDF
allfiles.cpp:06/26/2006  09:55 AM             7,680 dicttabl.CDX
allfiles.cpp:06/26/2006  09:55 AM               712 dicttabl.DBF
allfiles.cpp:06/26/2006  09:55 AM               512 dicttabl.FPT
allfiles.cpp:06/26/2006  09:55 AM            24,064 FldDict.RRW
allfiles.cpp:06/26/2006  09:55 AM               726 ownertmp.DBF
allfiles.cpp:06/26/2006  09:55 AM               766 rrdict.ico
allfiles.cpp:06/26/2006  09:55 AM            21,504 TblDict.RRW
allfiles.cpp:06/26/2006  09:55 AM            11,776 FldDict.RRW
allfiles.cpp:06/26/2006  09:55 AM            11,264 TblDict.RRW
allfiles.cpp:09/02/2006  02:35 PM             5,873 datadict.h
allfiles.cpp:09/02/2006  02:35 PM           301,643 LTDIC.H
allfiles.cpp:09/02/2006  02:35 PM           157,629 ltdicocx.h
allfiles.cpp:09/02/2006  02:35 PM           301,643 LTDIC.H
allfiles.cpp:09/02/2006  02:35 PM           157,629 ltdicocx.h
allfiles.cpp:09/02/2006  02:35 PM            12,080 ltcBtmp.h
allfiles.cpp:09/02/2006  02:35 PM             3,217 ltcDictn.h
allfiles.cpp:09/02/2006  02:35 PM           301,643 LTDIC.H
allfiles.cpp:09/02/2006  02:36 PM         3,162,743 ReportWorks Data Dictionary Editor.PDF
allfiles.cpp:04/30/2013  04:37 PM            38,661 Datadict.obj
allfiles.cpp:04/30/2013  05:03 PM                 0 Datadict.sbr
allfiles.cpp:10/17/2013  01:42 PM            66,759 Datadict.obj
allfiles.cpp:10/17/2013  01:41 PM           158,786 Datadict.sbr
allfiles.cpp:09/02/2006  02:36 PM           848,782 datadict.exe
allfiles.cpp:09/02/2006  02:36 PM           181,760 dictfld.CDX
allfiles.cpp:09/02/2006  02:36 PM            68,653 dictfld.DBF
allfiles.cpp:09/02/2006  02:36 PM             1,408 dictfld.FPT
allfiles.cpp:09/02/2006  02:36 PM             4,608 dictindx.CDX
allfiles.cpp:09/02/2006  02:36 PM               616 dictindx.DBF
allfiles.cpp:09/02/2006  02:36 PM               512 dictindx.FPT
allfiles.cpp:09/02/2006  02:36 PM         3,078,812 Dictionary Help.PDF
allfiles.cpp:09/02/2006  02:36 PM             7,680 dicttabl.CDX
allfiles.cpp:09/02/2006  02:36 PM             7,361 dicttabl.DBF
allfiles.cpp:09/02/2006  02:36 PM               512 dicttabl.FPT
allfiles.cpp:09/02/2006  02:36 PM            24,064 FldDict.RRW
allfiles.cpp:09/02/2006  02:36 PM               726 ownertmp.DBF
allfiles.cpp:09/02/2006  02:36 PM               766 rrdict.ico
allfiles.cpp:09/02/2006  02:36 PM            21,504 TblDict.RRW
allfiles.cpp:09/02/2006  02:36 PM           848,782 datadict.exe
allfiles.cpp:10/15/2013  05:11 PM           409,088 dictfld.CDX
allfiles.cpp:10/15/2013  05:11 PM           163,693 dictfld.DBF
allfiles.cpp:06/26/2006  09:57 AM             1,152 dictfld.FPT
allfiles.cpp:10/01/2013  01:23 PM             5,632 dictindx.CDX
allfiles.cpp:10/01/2013  01:23 PM             7,387 dictindx.DBF
allfiles.cpp:06/26/2006  09:57 AM               512 dictindx.FPT
allfiles.cpp:09/02/2006  02:36 PM         3,078,812 Dictionary Help.PDF
allfiles.cpp:10/15/2013  05:11 PM            12,800 dicttabl.CDX
allfiles.cpp:10/15/2013  05:11 PM            26,474 dicttabl.DBF
allfiles.cpp:06/26/2006  09:57 AM               512 dicttabl.FPT
allfiles.cpp:06/26/2006  09:57 AM            24,064 FldDict.RRW
allfiles.cpp:06/26/2006  09:57 AM               726 ownertmp.DBF
allfiles.cpp:09/02/2006  02:36 PM               766 rrdict.ico
allfiles.cpp:06/26/2006  09:57 AM            21,504 TblDict.RRW
allfiles.cpp:05/20/2008  07:39 AM           794,624 dictfld.CDX
allfiles.cpp:08/27/2008  02:14 PM           331,498 dictfld.DBF
allfiles.cpp:09/02/2006  02:36 PM             1,152 dictfld.FPT
allfiles.cpp:06/05/2008  02:20 PM             7,168 dictindx.CDX
allfiles.cpp:06/05/2008  02:20 PM            18,219 dictindx.DBF
allfiles.cpp:09/02/2006  02:36 PM               512 dictindx.FPT
allfiles.cpp:05/20/2008  07:39 AM            16,896 dicttabl.CDX
allfiles.cpp:05/20/2008  07:39 AM            38,108 dicttabl.DBF
allfiles.cpp:09/02/2006  02:36 PM               512 dicttabl.FPT
allfiles.cpp:09/02/2006  02:36 PM            24,064 FldDict.RRW
allfiles.cpp:09/02/2006  02:36 PM               726 ownertmp.DBF
allfiles.cpp:09/02/2006  02:36 PM            21,504 TblDict.RRW
allfiles.cpp:11/06/2013  06:19 PM            30,789 Datadict.obj
allfiles.cpp:11/06/2013  06:49 PM                 0 Datadict.sbr
allfiles.cpp:09/02/2006  02:36 PM           850,033 WZ27.tmp
allfiles.cpp:09/02/2006  02:36 PM           862,355 WZ2A.tmp
allfiles.cpp:09/02/2006  02:36 PM           853,131 WZ3D.tmp
allfiles.cpp:09/02/2006  02:36 PM           848,782 datadict.exe
allfiles.cpp:09/02/2006  02:36 PM            29,696 dictfld.CDX
allfiles.cpp:09/02/2006  02:36 PM             9,253 dictfld.DBF
allfiles.cpp:09/02/2006  02:36 PM               512 dictfld.FPT
allfiles.cpp:09/02/2006  02:36 PM             4,608 dictindx.CDX
allfiles.cpp:09/02/2006  02:36 PM             1,971 dictindx.DBF
allfiles.cpp:09/02/2006  02:36 PM               512 dictindx.FPT
allfiles.cpp:09/02/2006  02:36 PM         3,078,812 Dictionary Help.PDF
allfiles.cpp:09/02/2006  02:36 PM             7,680 dicttabl.CDX
allfiles.cpp:09/02/2006  02:36 PM             6,530 dicttabl.DBF
allfiles.cpp:09/02/2006  02:36 PM               512 dicttabl.FPT
allfiles.cpp:09/02/2006  02:36 PM            24,064 FldDict.RRW
allfiles.cpp:09/02/2006  02:36 PM               726 ownertmp.DBF
allfiles.cpp:09/02/2006  02:36 PM               766 rrdict.ico
allfiles.cpp:09/02/2006  02:36 PM            21,504 TblDict.RRW
allfiles.cpp:09/02/2006  02:36 PM           848,782 datadict.exe
allfiles.cpp:06/26/2006  09:58 AM            44,032 dictfld.CDX
allfiles.cpp:06/26/2006  09:58 AM            16,381 dictfld.DBF
allfiles.cpp:06/26/2006  09:58 AM               640 dictfld.FPT
allfiles.cpp:06/26/2006  09:58 AM             4,608 dictindx.CDX
allfiles.cpp:06/26/2006  09:58 AM             1,970 dictindx.DBF
allfiles.cpp:06/26/2006  09:58 AM               512 dictindx.FPT
allfiles.cpp:09/02/2006  02:36 PM         3,078,812 Dictionary Help.PDF
allfiles.cpp:06/26/2006  09:58 AM             7,680 dicttabl.CDX
allfiles.cpp:06/26/2006  09:58 AM             6,530 dicttabl.DBF
allfiles.cpp:06/26/2006  09:58 AM               512 dicttabl.FPT
allfiles.cpp:06/26/2006  09:58 AM            24,064 FldDict.RRW
allfiles.cpp:06/26/2006  09:58 AM               726 ownertmp.DBF
allfiles.cpp:09/02/2006  02:36 PM               766 rrdict.ico
allfiles.cpp:06/26/2006  09:58 AM            21,504 TblDict.RRW
allfiles.cpp:05/21/2008  09:20 AM           276,992 dictfld.CDX
allfiles.cpp:08/28/2008  06:53 AM           113,500 dictfld.DBF
allfiles.cpp:09/02/2006  02:36 PM               640 dictfld.FPT
allfiles.cpp:02/13/2008  08:58 AM             5,632 dictindx.CDX
allfiles.cpp:02/13/2008  08:58 AM             7,387 dictindx.DBF
allfiles.cpp:09/02/2006  02:36 PM               512 dictindx.FPT
allfiles.cpp:05/21/2008  09:20 AM            12,288 dicttabl.CDX
allfiles.cpp:05/21/2008  09:20 AM            21,488 dicttabl.DBF
allfiles.cpp:09/02/2006  02:36 PM               512 dicttabl.FPT
allfiles.cpp:09/02/2006  02:36 PM            24,064 FldDict.RRW
allfiles.cpp:09/02/2006  02:36 PM               726 ownertmp.DBF
allfiles.cpp:09/02/2006  02:36 PM            21,504 TblDict.RRW
allfiles.cpp:10/22/2013  04:45 PM            66,843 DATADICT.obj
allfiles.cpp:10/22/2013  04:44 PM           161,163 DATADICT.sbr
allfiles.cpp:09/02/2006  02:37 PM           848,782 datadict.exe
allfiles.cpp:10/23/2013  09:34 AM           288,768 dictfld.CDX
allfiles.cpp:10/23/2013  09:34 AM            75,187 dictfld.DBF
allfiles.cpp:09/02/2006  02:37 PM               512 dictfld.FPT
allfiles.cpp:09/02/2006  02:37 PM             4,608 dictindx.CDX
allfiles.cpp:09/02/2006  02:37 PM               616 dictindx.DBF
allfiles.cpp:09/02/2006  02:37 PM               512 dictindx.FPT
allfiles.cpp:09/02/2006  02:37 PM         3,078,812 Dictionary Help.PDF
allfiles.cpp:10/23/2013  09:34 AM            12,800 dicttabl.CDX
allfiles.cpp:10/23/2013  09:34 AM            18,164 dicttabl.DBF
allfiles.cpp:09/02/2006  02:37 PM               512 dicttabl.FPT
allfiles.cpp:09/02/2006  02:37 PM            24,064 FldDict.RRW
allfiles.cpp:09/02/2006  02:37 PM               726 ownertmp.DBF
allfiles.cpp:09/02/2006  02:37 PM               766 rrdict.ico
allfiles.cpp:09/02/2006  02:37 PM            21,504 TblDict.RRW
allfiles.cpp:11/07/2013  09:43 AM            30,983 DATADICT.obj
allfiles.cpp:11/07/2013  10:02 AM                 0 DATADICT.sbr
allfiles.cpp:09/02/2006  02:37 PM           829,293 WZ20.tmp
allfiles.cpp:09/02/2006  02:37 PM           820,016 WZ34.tmp
allfiles.cpp:09/02/2006  02:37 PM           758,714 datadict.exe
allfiles.cpp:05/30/2008  09:19 AM           164,352 dictfld.CDX
allfiles.cpp:06/05/2008  10:11 AM            41,329 dictfld.DBF
allfiles.cpp:09/02/2006  02:37 PM               576 dictfld.FPT
allfiles.cpp:09/02/2006  02:37 PM             4,608 dictindx.CDX
allfiles.cpp:09/02/2006  02:37 PM               616 dictindx.DBF
allfiles.cpp:09/02/2006  02:37 PM               512 dictindx.FPT
allfiles.cpp:05/30/2008  09:19 AM            11,776 dicttabl.CDX
allfiles.cpp:05/30/2008  09:19 AM            14,840 dicttabl.DBF
allfiles.cpp:09/02/2006  02:37 PM               512 dicttabl.FPT
allfiles.cpp:09/02/2006  02:37 PM            24,064 FldDict.RRW
allfiles.cpp:09/02/2006  02:37 PM               726 ownertmp.DBF
allfiles.cpp:09/02/2006  02:37 PM               766 rrdict.ico
allfiles.cpp:09/02/2006  02:37 PM            21,504 TblDict.RRW
allfiles.cpp:11/07/2013  02:54 PM            66,140 DATADICT.obj
allfiles.cpp:11/07/2013  03:11 PM                 0 DATADICT.sbr
allfiles.cpp:09/02/2006  02:38 PM           848,782 datadict.exe
allfiles.cpp:09/02/2006  02:38 PM            16,384 dictfld.CDX
allfiles.cpp:09/02/2006  02:38 PM             3,907 dictfld.DBF
allfiles.cpp:09/02/2006  02:38 PM               512 dictfld.FPT
allfiles.cpp:09/02/2006  02:38 PM             4,608 dictindx.CDX
allfiles.cpp:09/02/2006  02:38 PM               616 dictindx.DBF
allfiles.cpp:09/02/2006  02:38 PM               512 dictindx.FPT
allfiles.cpp:09/02/2006  02:38 PM         3,078,812 Dictionary Help.PDF
allfiles.cpp:09/02/2006  02:38 PM             7,680 dicttabl.CDX
allfiles.cpp:09/02/2006  02:38 PM             3,206 dicttabl.DBF
allfiles.cpp:09/02/2006  02:38 PM               512 dicttabl.FPT
allfiles.cpp:09/02/2006  02:38 PM            24,064 FldDict.RRW
allfiles.cpp:09/02/2006  02:38 PM               726 ownertmp.DBF
allfiles.cpp:09/02/2006  02:38 PM               766 rrdict.ico
allfiles.cpp:09/02/2006  02:38 PM            21,504 TblDict.RRW
allfiles.cpp:11/20/2013  03:42 PM            30,236 DATADICT.obj
allfiles.cpp:11/20/2013  03:41 PM           150,328 DATADICT.sbr
allfiles.cpp:09/02/2006  02:38 PM           576,405 WZ4C.tmp
allfiles.cpp:09/02/2006  02:38 PM           848,782 datadict.exe
allfiles.cpp:09/02/2006  02:38 PM            16,384 dictfld.CDX
allfiles.cpp:09/02/2006  02:38 PM             3,907 dictfld.DBF
allfiles.cpp:09/02/2006  02:38 PM               512 dictfld.FPT
allfiles.cpp:09/02/2006  02:38 PM             4,608 dictindx.CDX
allfiles.cpp:09/02/2006  02:38 PM               616 dictindx.DBF
allfiles.cpp:09/02/2006  02:38 PM               512 dictindx.FPT
allfiles.cpp:09/02/2006  02:38 PM         3,078,812 Dictionary Help.PDF
allfiles.cpp:09/02/2006  02:38 PM             7,680 dicttabl.CDX
allfiles.cpp:09/02/2006  02:38 PM             3,206 dicttabl.DBF
allfiles.cpp:09/02/2006  02:38 PM               512 dicttabl.FPT
allfiles.cpp:09/02/2006  02:38 PM            24,064 FldDict.RRW
allfiles.cpp:09/02/2006  02:38 PM               726 ownertmp.DBF
allfiles.cpp:09/02/2006  02:38 PM               766 rrdict.ico
allfiles.cpp:09/02/2006  02:38 PM            21,504 TblDict.RRW
allfiles.cpp:11/20/2013  05:02 PM            30,320 DATADICT.obj
CFCOMP\cfcomp.cpp:#include "datadict.h"
CFCOMP\cfcomp.cpp:		//  the keyword indicates that we are doing something of
CFCOMP\compile.cpp:	FirstErr = 0;		// used to prevent Data Dictionary checks after first try
CFCOMP\explt.cpp://	6/02/93 sjo - I added an argument to lexplt(). This argument indicates
CFCOMP\explt.cpp: int 			action	/* indicates why explt is being called - this is for */
CFCOMP\explt.cpp:			case a_keyword:			// Keyword is followed by a char indicating the 
CFCOMP\explt.cpp:				xcp++;				// class of keyword, followed by a char indicating the value of the keyword
CFCOMP\RSW\xeval.cpp:// Use decimal indicator in format numeric literals
CFCOMP\token.cpp:	that we substitute for the keyword, as well as a flag indicating
CFEDIT\editcalc.cpp://  needed by runtime in support of data dictionary.
CFEVAL\eval.cpp:	// Push a keyword.  For now, keywords have an sv_ type indicator
CFEVAL\eval.cpp:	//  by an int indicating the actual keyword.
CFEVAL\eval.cpp:				xcp+=2;				// Char indicating sv_<interval>, char for keyval
CFEVAL\fdate.cpp:	pDoc->m_pComposite->cknoarg();	/* pop the no argument indicator */
CFEVAL\fdate.cpp:	pDoc->m_pComposite->cknoarg();	/* pop the no argument indicator */
CFEVAL\fdate.cpp:/* NDOW(date1, dow) returns the date of the day indicated by dow day 
CFEVAL\fdate.cpp:/* PDOW(date1, dow) returns the date of the day indicated by dow day 
CFEVAL\fdate.cpp:	BOOL	   Negative;	// Indicates whether or not we have negative seconds.	
CFEVAL\fdate.cpp:	pDoc->m_pComposite->cknoarg();	/* pop the no argument indicator */
CFEVAL\fnum.cpp:	pDoc->m_pComposite->cknoarg();	/* pop the no argument indicator */
CFEVAL\fnum.cpp:	pDoc->m_pComposite->cknoarg();	/* pop the no argument indicator */
CFEVAL\fnum.cpp:	pDoc->m_pComposite->cknoarg();	/* pop the no argument indicator */
CFEVAL\fnum.cpp:	pDoc->m_pComposite->cknoarg();	/* pop the no argument indicator */
CFEVAL\fnum.cpp:	pDoc->m_pComposite->cknoarg();	/* pop "no argument" indicator */
CFEVAL\fnum.cpp:	pDoc->m_pComposite->cknoarg();			/* pop the no argument indicator */
CFEVAL\fsystem.cpp:	pDoc->m_pComposite->cknoarg();	/* pop the no argument indicator */
CFEVAL\RRW\lookup.cpp:			return TRUE;		// we don't support NULLable keyed indices yet
CFMISC\cfneeded.cpp://	dependency evalutor - sets flags in dependent fields indicating needed
CFMISC\cfrepnm.cpp:// Merge from Abra branch:  Added lcfqualifyall() for use by data dict code.
CFMISC\cfrepnm.cpp://  got predefined calcs in a data dictionary.
CFMISC\cfrepnm.cpp:#include "datadict.h"		// for SecurityLevel
CFMISC\strtod.cpp:							<timestring> contains no spaces, has an optional trailing AM/PM indicator,
CFMISC\ulibr.cpp:	LPYZNAME yn, tmp;
CFMISC\ulibr.cpp:		for (tmp=yn; tmp; tmp=tmp->yznLk)
CFMISC\ulibr.cpp:			if (tmp->yznName[0])
CFMISC\ulibr.cpp:				if (urddef(tmp, false, FALSE))
CFMISC\ulibr.cpp:					tmp->yznName[0] = '\0';
CFMISC\ulibr.cpp:	for (tmp=yn; tmp; tmp=tmp->yznLk)
CFMISC\ulibr.cpp:		if (tmp->yznName[0])
CFMISC\ulibr.cpp:			urddef(tmp, false, TRUE);
CFMISC\ulibr.cpp:		for (tmp=yn; tmp; tmp=tmp->yznLk)
CFMISC\ulibr.cpp:			if (tmp->yznName[0])
CFMISC\ulibr.cpp:				if (urddef(tmp, true, FALSE))
CFMISC\ulibr.cpp:					tmp->yznName[0] = '\0';
CFMISC\ulibr.cpp:	for (tmp=yn; tmp; tmp=tmp->yznLk)
CFMISC\ulibr.cpp:		if (tmp->yznName[0])
CFMISC\ulibr.cpp:			urddef(tmp,true, TRUE);
chart\rrchart.cpp:	m_Anchor = aTOP;			// enum value indicating anchor-top or anchor-bottom
chart\rrchart.cpp:	m_Anchor			= src.m_Anchor;			// enum value indicating anchor-top or anchor-bottom
chart\rrchart.cpp:			arChartArchive << (DWORD)m_Anchor;		// enum value indicating anchor-top or anchor-bottom
chart\rrchart.cpp:			m_Anchor = (ANCHOR)dwTemp;				// enum value indicating anchor-top or anchor-bottom
chart\rrchlist.cpp:			// If in a header and LastBreakLevel indicated it's time to quit,
chart\rrchlist.cpp:			// If in a header and LastBreakLevel indicated it's time to quit,
DATADICT\datadict.cpp:// This module contains the routines for data dictionary.
DATADICT\datadict.cpp://			the dictionary file.
DATADICT\datadict.cpp://	When ddsetup() matches a mffield with a dictionary entry, it mallocs
DATADICT\datadict.cpp:// $Log:   D:/R&R Project/archives/DATADICT/DATADICT.CPV  $
DATADICT\datadict.cpp:// Temp. save of dictionary properties
DATADICT\datadict.cpp:// New dictionary format
DATADICT\datadict.cpp:// Add sanity check on dictionary index's key length as compared with sum
DATADICT\datadict.cpp:// dict error, now that have calc & tot comments, could remove them too.
DATADICT\datadict.cpp://  an invalid or missing data dictionary or dd index.  Related to RRW
DATADICT\datadict.cpp:// Moved DATADICT stuff to application class.
DATADICT\datadict.cpp://  report dictionaries and predefined calcs that end up associated with
DATADICT\datadict.cpp://  just because some bozo makes a datadict with a field_name field wider
DATADICT\datadict.cpp:// Part of fix to RSW bug 1527.  Use sql_prep_tablename_for_dict().
DATADICT\datadict.cpp:// Part of fix to RSW bug 1527.  Use sql_prep_tablename_for_dict() to
DATADICT\datadict.cpp://  build dict search string.  Changes in eng.h and iengine.c, too.
DATADICT\datadict.cpp:// Fixes RSW bug 1376, which states that the data dictionary doesn't handle
DATADICT\datadict.cpp://  pay attention to the data dictionary info.  'R' is a valid value in the
DATADICT\datadict.cpp://  dictionary info in the runtime if we're doing some interactive feature
DATADICT\datadict.cpp://  data dictionary index.
DATADICT\datadict.cpp://  dictionary fields we're interested in.
DATADICT\datadict.cpp://  data dictionary.  Affected modules include:  datadict.h, mffield.h,
DATADICT\datadict.cpp:// Added data dictionary support for RSW.
DATADICT\datadict.cpp:// Added three new dictionary fields:
DATADICT\datadict.cpp://    a logical that indicates the field should be discarded by R&R
DATADICT\datadict.cpp://    a logical that indicates the field should not be presented in
DATADICT\datadict.cpp://    a logical that indicates the field should not be part of an
DATADICT\datadict.cpp://  DATADICT isn't defined.
DATADICT\datadict.cpp://  the data-dictionary feature was originally developed for RRW, so this
DATADICT\datadict.cpp://  with data-dictionary index.  It was limited to 20 characters or some
DATADICT\datadict.cpp:// Changed open mode for data dictionary memo file to deny-none.
DATADICT\datadict.cpp:#if defined(DATADICT)		// skip this whole module if DATADICT not on
DATADICT\datadict.cpp:#define _DATADICT_C_
DATADICT\datadict.cpp:	#include "datadict.h"
DATADICT\datadict.cpp:	#include "eng.h"		// for sql_prep_tablename_for_dict()
DATADICT\datadict.cpp:// holds location (offset) and length of dictionary fields
DATADICT\datadict.cpp:	} dictRecord ;
DATADICT\datadict.cpp://	Read a calc field formula from a data-dictionary memo-file record
DATADICT\datadict.cpp:	if (!dictRecord.memopos)
DATADICT\datadict.cpp:	memobegpos = dictRecord.memopos * memoblksz;
DATADICT\datadict.cpp:			if (dictRecord.hidefilt)						// remember whether or not to allow in filter list
DATADICT\datadict.cpp:			if (dictRecord.hideinst)						// ... to include in instant report
DATADICT\datadict.cpp:			if (newfld->comment = pDoc->globalAlloc(GMEM_FIXED,_tcslen(dictRecord.comment)+1))
DATADICT\datadict.cpp:				_tcscpy(newfld->comment,dictRecord.comment);
DATADICT\datadict.cpp: 			// get properties from dict and lay them into field
DATADICT\datadict.cpp:			if (newfld->dict.dLength != 0)
DATADICT\datadict.cpp:				newfld->dLength = newfld->dict.dLength ;
DATADICT\datadict.cpp:			if (newfld->dict.dFldPic != 0)
DATADICT\datadict.cpp:				newfld->dFldPic = newfld->dict.dFldPic ;
DATADICT\datadict.cpp:			if (newfld->dict.dDecPl != 0)
DATADICT\datadict.cpp:				newfld->dDecPl = newfld->dict.dDecPl - 1 ;
DATADICT\datadict.cpp:			switch (newfld->dict.align)
DATADICT\datadict.cpp://	open the dictionary file
DATADICT\datadict.cpp:	// open dictionary file
DATADICT\datadict.cpp:#if !defined(PASSWORD_REQD)		// if a data dictionary is optional
DATADICT\datadict.cpp:	if (dbfile.Read( (LPSTR)&dictHead, sizeof(DBHEADER) ) != sizeof(DBHEADER))
DATADICT\datadict.cpp:	if ((dictHead.inctrans) || (dictHead.encrypt))
DATADICT\datadict.cpp:	if (dictHead.version == 0xF5)
DATADICT\datadict.cpp:		unsigned char version = dictHead.version & 0x8F;
DATADICT\datadict.cpp:	//	endrec = dictHead.headlen + 1 + (dictHead.reclen * dictHead.numrecs);
DATADICT\datadict.cpp:	for (i=FSTFIELD;  (i < (long)(dictHead.headlen)) && (allflds); i+=NXTFIELD)
DATADICT\datadict.cpp:#if defined(PASSWORD_REQD)			// require a security-level field unless dictionary is optional
DATADICT\datadict.cpp://	open the dictionary index with tagname
DATADICT\datadict.cpp:	pDoc->m_pComposite->MFShMode = CFile::shareDenyNone;		// always allow writes to dict index
DATADICT\datadict.cpp://	close the dictionary dbf, and memo
DATADICT\datadict.cpp://	close the dictionary dbf, and memo
DATADICT\datadict.cpp://		pDoc->m_pComposite->sql_prep_tablename_for_dict (pDoc->m_pComposite->MFFiles[fileno]->mDbfName, tempbuf);
DATADICT\datadict.cpp://	read the dictionary file record at reco
DATADICT\datadict.cpp://	and put the stuff in DictRecord
DATADICT\datadict.cpp:	long	fileloc;		// comment location in dictionary file
DATADICT\datadict.cpp:	if (!(record = pDoc->globalAlloc(GMEM_MOVEABLE,dictHead.reclen + 1)))
DATADICT\datadict.cpp:		fileloc = dictHead.headlen + (dictHead.reclen * --recno);
DATADICT\datadict.cpp:			|| ( dbfile.Read( record, dictHead.reclen ) != dictHead.reclen ))
DATADICT\datadict.cpp:	dictRecord.showtype = EXTENDED_LENGTH && ((toupper(record[EXTENDED_OFFSET]) == T) || (toupper(record[EXTENDED_OFFSET]) == 'Y'));
DATADICT\datadict.cpp:	dictRecord.hidefld = FIELD_HIDE_LENGTH && ((toupper(record[FIELD_HIDE_OFFSET]) == T) || (toupper(record[FIELD_HIDE_OFFSET]) == 'Y'));
DATADICT\datadict.cpp:	dictRecord.hidefilt = FILTR_HIDE_LENGTH && ((toupper(record[FILTR_HIDE_OFFSET]) == T) || (toupper(record[FILTR_HIDE_OFFSET]) == 'Y'));
DATADICT\datadict.cpp:	dictRecord.hideinst = INST_HIDE_LENGTH && ((toupper(record[INST_HIDE_OFFSET]) == T) || (toupper(record[INST_HIDE_OFFSET]) == 'Y'));
DATADICT\datadict.cpp:	dictRecord.size_disp = ascii_to_int(&record[SIZE_DISP_OFFSET],SIZE_DISP_LENGTH)  ;
DATADICT\datadict.cpp:	dictRecord.dec_disp = ascii_to_int(&record[DEC_DISP_OFFSET],DEC_DISP_LENGTH)  ;
DATADICT\datadict.cpp:	dictRecord.form_disp = record[FORM_DISP_OFFSET] ;
DATADICT\datadict.cpp:	dictRecord.align_disp = record[ALIGN_DISP_OFFSET] ;
DATADICT\datadict.cpp:	dictRecord.fld_type = record[FLD_TYPE_OFFSET] ;
DATADICT\datadict.cpp:	strncpy(dictRecord.memoname,&(record[FIELD_NAME_OFFSET]),memonamelen);
DATADICT\datadict.cpp:	dictRecord.memoname[memonamelen-1] = 0;
DATADICT\datadict.cpp:	j = zcutoff(dictRecord.memoname,' ');
DATADICT\datadict.cpp:		seclvl = dictRecord.memoname[j-1];
DATADICT\datadict.cpp:			seclvl += (dictRecord.memoname[j-1] - ' ');
DATADICT\datadict.cpp:		if (dictRecord.security = atoi(&(record[SECURITY_OFFSET])))	// sec lvl from data dict.
DATADICT\datadict.cpp:			dictRecord.security -= seclvl;					// if non-zero, remove fieldname encryption
DATADICT\datadict.cpp:		dictRecord.security = 0;
DATADICT\datadict.cpp:	strncpy (dictRecord.comment,&(record[COMMENT_OFFSET]),COMMENT_LENGTH);
DATADICT\datadict.cpp:	dictRecord.comment[COMMENT_LENGTH] = 0;
DATADICT\datadict.cpp:	for(j=COMMENT_LENGTH; (j>0) && (dictRecord.comment[j-1] == ' '); j--)
DATADICT\datadict.cpp:	dictRecord.comment[j] = '\0';
DATADICT\datadict.cpp://		dictRecord.memopos = atol(&(record[FORMULA_OFFSET]));	// doesn't work for "dialog" .DBFs
DATADICT\datadict.cpp:		dictRecord.memopos = *(long *)(record+FORMULA_OFFSET) ;
DATADICT\datadict.cpp:		dictRecord.memopos = 0L;
DATADICT\datadict.cpp:	if (!pDoc->Defs.Dictionary || DDdoNothing)
DATADICT\datadict.cpp:	// if there is a dictionary file, open it up!
DATADICT\datadict.cpp:		if (dictRecord.hidefld
DATADICT\datadict.cpp:			 || (dictRecord.security > SecurityLevel)
DATADICT\datadict.cpp://	else error = TRUE;	// better be a data dictionary, or else
DATADICT\datadict.cpp:	//  mfrlsfld() gets called for the datadict copy.  This results in the dExpE
DATADICT\datadict.cpp://	This allows us to save reports that have bad calcs from data dict.
DATADICT\datadict.cpp://	main function to read the data dictionary information for each
DATADICT\datadict.cpp:	if (!pDoc->Defs.Dictionary ||
DATADICT\datadict.cpp:	// if runtime, only set up dictionary if interactive query
DATADICT\datadict.cpp:		// if there is a dictionary file, open it up!
DATADICT\datadict.cpp:		if (ddopenindex("dictfld"))
DATADICT\datadict.cpp:				fld->dShowType = dictRecord.showtype;
DATADICT\datadict.cpp:				fld->dSecurity = dictRecord.security;
DATADICT\datadict.cpp:				if (dictRecord.hidefld
DATADICT\datadict.cpp:				 || (dictRecord.security > SecurityLevel)
DATADICT\datadict.cpp:					if ((dictRecord.comment[0] != '\0')
DATADICT\datadict.cpp:					 && (fld->comment = pDoc->globalAlloc(GMEM_FIXED,strlen(dictRecord.comment)+1)))
DATADICT\datadict.cpp:						lstrcpy(fld->comment,dictRecord.comment);
DATADICT\datadict.cpp:					if (dictRecord.hidefilt)
DATADICT\datadict.cpp:					if (dictRecord.hideinst)
DATADICT\datadict.cpp:			else	// not in data dictionary
DATADICT\datadict.cpp:		if (!ddopenindex("dictcalc"))
DATADICT\datadict.cpp:	fld->dict.dLength = dictRecord.size_disp ;
DATADICT\datadict.cpp:	switch (dictRecord.align_disp)
DATADICT\datadict.cpp:		fld->dict.align = dictRecord.align_disp ;
DATADICT\datadict.cpp:	switch (dictRecord.fld_type)
DATADICT\datadict.cpp:		fld->dict.dDecPl = dictRecord.dec_disp + 1;
DATADICT\datadict.cpp:		switch (dictRecord.form_disp)
DATADICT\datadict.cpp:		fld->dict.dFldPic = (fld->dFldPic & ~0xf) | pic ;
DATADICT\datadict.cpp:		switch (dictRecord.form_disp)
DATADICT\datadict.cpp:		fld->dict.dFldPic = (fld->dFldPic & ~0xf0ff) | pic ;
DATADICT\datadict.cpp:	// use its dictionary properties
DATADICT\datadict.cpp:		if (fld->dict.dLength != 0)
DATADICT\datadict.cpp:			fld->dLength = fld->dict.dLength ;
DATADICT\datadict.cpp:		if (fld->dict.dFldPic != 0)
DATADICT\datadict.cpp:			fld->dFldPic = fld->dict.dFldPic ;
DATADICT\datadict.cpp:		if (fld->dict.dDecPl != 0)
DATADICT\datadict.cpp:			fld->dDecPl = fld->dict.dDecPl - 1 ;
DATADICT\datadict.cpp:		switch (fld->dict.align)
DATADICT\datadict.cpp:	// Now process all data dictionary entries looking
DATADICT\datadict.cpp:			ddmakecalc(dictRecord.memoname, *firstfld, alias, FALSE);	// try to turn it into a calc field
DATADICT\datadict.cpp:	// Now process data dictionary entries looking for 
DATADICT\datadict.cpp:					ddmakecalc(dictRecord.memoname, *firstfld, alias, TRUE);	// try to turn it into a calc field
DATADICT\datadict.cpp:	if (!pDoc->Defs.Dictionary || DDdoNothing)
DATADICT\datadict.cpp:	// multi-file reports when error reading dictionary file (because didn't
DATADICT\datadict.cpp:	// dict and then clean up and get rid of all comments.  This is bad.  I got
DATADICT\datadict.cpp://	get eval-once calcs from data dict when no master (mfopen not called then)
DATADICT\datadict.cpp: #if defined(DATADICT)
DATADICT\datadict.cpp://	look in dictbl.dbf to find an alias for filename
DATADICT\datadict.cpp:	if (!pDoc->Defs.Dictionary)
DATADICT\datadict.cpp:	// open the dictionary table file
DATADICT\datadict.cpp:	sprintf(pathname, "%s%s", theApp.Paths->LibrarianDataPath, "dicttabl.dbf") ;
DATADICT\datadict.cpp:	if (dbfile.Read( (LPSTR)&dictHead, sizeof(DBHEADER) ) != sizeof(DBHEADER))
DATADICT\datadict.cpp:	if ((dictHead.inctrans) || (dictHead.encrypt))
DATADICT\datadict.cpp:			i < (long)(dictHead.headlen) ;
DATADICT\datadict.cpp:	sprintf(indexpathname, "%s%s", theApp.Paths->LibrarianDataPath, "dicttabl.cdx") ;
DATADICT\datadict.cpp:	if (!(record = pDoc->globalAlloc(GMEM_MOVEABLE,dictHead.reclen + 1)))
DATADICT\datadict.cpp:		fileloc = dictHead.headlen + (dictHead.reclen * --recno);
DATADICT\datadict.cpp:			|| ( dbfile.Read( record, dictHead.reclen ) != dictHead.reclen ))
DATADICT\datadict.cpp:#endif	// #if defined(DATADICT)
DCALC\dcalctot.cpp:// Fix filter for Add to Dictionary fields
DCALC\dcalctot.cpp:// Tighter check of "Add to Dict." button
DCALC\dcalctot.cpp:// fixed bug 1598 1084 data dictionary comments wider than width of box.
DCALC\dcalctot.cpp:// Added code, conditional on DATADICT, from Abra branch, to test for
DCALC\dcalctot.cpp:							pDoc->Defs.Dictionary &&
DCALC\dcalctot.cpp:	// check to see if "Add to Dict." should be enabled
DCALC\dcalctot.cpp://		::EnableWindow(::GetDlgItem(hDlg, DEDADD), pDoc->Defs.Dictionary && calcAddFilter(f));
DCALC\dcalctot.cpp:// see if the field f is eligible to be added to the dictionary
DCALC\dcalctot.cpp:#if defined(DATADICT)
DCALC\dcalctot.cpp:#if defined(DATADICT)
DCALC\dcalctot.cpp:							pDoc->Defs.Dictionary &&
DCALC\dcalctot.cpp:		pDoc->m_pComposite->UpdateDictionaryCalcField(f) ;
DCALC\dparams.cpp:	pImageListSmall->Add(pApp->LoadIcon(IDI_ICON_BLANK));
DCALC\dparams.cpp:	pImageListSmall->Add(pApp->LoadIcon(IDI_ICON_GO));
DCALC\dparams.cpp:// set the default indicator on selected item
DCALC\dparams.cpp:	pImageListSmall->Add(pApp->LoadIcon(IDI_ICON_UNCHECK));
DCALC\dparams.cpp:	pImageListSmall->Add(pApp->LoadIcon(IDI_ICON_CHECK));
DCALC\dtotal.cpp://  field-to-be-totaled list, and click Options button, we sort of indicate
DCALC\dtotal.cpp://  field-to-be-totaled list, and click Options button, we sort of indicate
DCALC\dtotal.cpp:				next = 0L;	// error indicator
DCALC\dtotals.cpp:	pImageListSmall->Add(pApp->LoadIcon(IDI_ICON_GO));
DCALC\dtotals.cpp:	pImageListSmall->Add(pApp->LoadIcon(IDI_ICON_MAYBE));
DCALC\dtotals.cpp:	pImageListSmall->Add(pApp->LoadIcon(IDI_ICON_NOGO));
DDATA\dquery.cpp:// Fixes RRW bug 1771 with datadict.c, grfield.c.
DDATA\RRW\xddata.cpp:// Use alias from dictionary
DDATA\RRW\xddata.cpp:					pDoc->m_pComposite->UpdateDictionaryFile(0, keyExpression) ;
DDATA\RRW\xdrelate.cpp:// Update dictionary call
DDATA\RRW\xdrelate.cpp:		pDoc->m_pComposite->UpdateDictionaryFile(rs.fileno, keyExpression) ;
DDATA\RRW\xdrelate.cpp:		pDoc->m_pComposite->UpdateDictionaryFile(rs.fileno, keyExpression) ;
DDATA\RRW\xdrelate.cpp://??????				::EnableWindow(hwndJoinHelp, pDoc->Defs.Dictionary);
DDATA\RRW\xdrelate.cpp://		::EnableWindow(hwndJoinHelp, pDoc->Defs.Dictionary);
DDATA\RRW\xdrelate.cpp://		::EnableWindow(hwndJoinHelp, pDoc->Defs.Dictionary);
DDATA\RRW\xdrelate.cpp://			::EnableWindow(::GetDlgItem(hDlg,DIALOGJOINHELP), pDoc->Defs.Dictionary);
DDATA\RRW\xdrelate.cpp://		::EnableWindow(hwndJoinHelp, pDoc->Defs.Dictionary);
DDATA\RRW\xdrelate.cpp://		::EnableWindow(hwndJoinHelp, pDoc->Defs.Dictionary);
DDATA\RRW\xdrelate.cpp://		::EnableWindow(hwndJoinHelp, pDoc->Defs.Dictionary);
DDATA\RRW\xdrelate.cpp://		::EnableWindow(hwndJoinHelp, pDoc->Defs.Dictionary);
DDATA\RRW\xdrelate.cpp:				::EnableWindow(hwndJoinHelp, pDoc->Defs.Dictionary);
DDATA\RRW\xdrelate.cpp:					::EnableWindow(GetDlgItem(hDlg, DIALOGJOINHELP), pDoc->Defs.Dictionary);
DDATA\RRW\xdrelate.cpp:					pDoc->m_pComposite->UpdateDictionaryFile(rs.fileno, keyExpression) ;
DDATA\RRW\xdrelate.cpp:					pDoc->m_pComposite->UpdateDictionaryFile(rs.fileno, keyExpression) ;
DDATA\RSW\sddata.cpp:// Update dictionary
DDATA\RSW\sddata.cpp:					pDoc->m_pComposite->UpdateDictionaryFile(0, NULL) ;
DDATA\RSW\sdrelate.cpp:// Update dictionary
DDATA\RSW\sdrelate.cpp://  or data dictionary descriptions, or both) in join dialog.  This is hairy
DDATA\RSW\sdrelate.cpp:	int nTmpFileNum, err;
DDATA\RSW\sdrelate.cpp:		if (err=m_pComposite->lmfopen(relfile,(int *)&nTmpFileNum,TRUE,NULL,NULL,FALSE,NULL,NULL))
DDATA\RSW\sdrelate.cpp://		bNeedOpen ? m_pComposite->MFFiles[nTmpFileNum] : m_pComposite->lfilen(filenum), initSel, relFldFilter,TRUE);
DDATA\RSW\sdrelate.cpp:	initSTFldList(bNeedOpen ? m_pComposite->MFFiles[nTmpFileNum] : m_pComposite->lfilen(filenum), initSel, relFldFilter);
DDATA\RSW\sdrelate.cpp:		m_pComposite->mfclose(nTmpFileNum, TRUE);
DDATA\RSW\sdrelate.cpp:			m_pComposite->sql_prep_tablename_for_dict((LPSTR)m_pComposite->MFFiles[fileNo]->mDbfName, (LPSTR)tempbuf);
DDATA\RSW\sdrelate.cpp:			::EnableWindow(GetDlgItem(hDlg,DIALOGJOINHELP), pDoc->Defs.Dictionary);
DDATA\RSW\sdrelate.cpp:				pDoc->m_pComposite->sql_prep_tablename_for_dict((LPSTR)pDoc->m_pComposite->MFFiles[fileNo]->mDbfName, (LPSTR)tempbuf);
DDATA\RSW\sdrelate.cpp:			pDoc->m_pComposite->sql_prep_tablename_for_dict((LPSTR)pDoc->rs.relfile,
DDATA\RSW\sdrelate.cpp:				pDoc->m_pComposite->sql_prep_tablename_for_dict((LPSTR)pDoc->m_pComposite->MFFiles[0]->mDbfName, (LPSTR)tempbuf);
DDATA\RSW\sdrelate.cpp:												// +82 for possible data dict description, colon, space
DDATA\RSW\sdrelate.cpp:					pDoc->m_pComposite->sql_prep_tablename_for_dict((LPSTR)pDoc->m_pComposite->MFFiles[fileNo]->mDbfName, (LPSTR)tempbuf);
DDATA\RSW\sdrelate.cpp:						::EnableWindow(GetDlgItem(hDlg,DIALOGJOINHELP), pDoc->Defs.Dictionary);
DDATA\RSW\sdrelate.cpp:						pDoc->m_pComposite->sql_prep_tablename_for_dict((LPSTR)pDoc->m_pComposite->MFFiles[fileNo]->mDbfName, (LPSTR)tempbuf);
DDATA\RSW\sdrelate.cpp:							::EnableWindow(GetDlgItem(hDlg,DIALOGJOINHELP), pDoc->Defs.Dictionary);
DDATA\RSW\sdrelate.cpp:					pDoc->m_pComposite->sql_prep_tablename_for_dict((LPSTR)pDoc->rs.relfile,
DDATA\RSW\sdrelate.cpp:					pDoc->m_pComposite->sql_prep_tablename_for_dict((LPSTR)pDoc->rs.relfile, (LPSTR)tempbuf);
DDATA\RSW\sdrelate.cpp:				::EnableWindow(GetDlgItem(hDlg,DIALOGJOINHELP), pDoc->Defs.Dictionary);
DDATA\RSW\sdrelate.cpp:					pDoc->m_pComposite->UpdateDictionaryFile(pDoc->rs.fileno, pDoc->rs.joinspec[0].rfld) ;
DDATA\RSW\sdrelate.cpp:				pDoc->m_pComposite->UpdateDictionaryFile(pDoc->rs.fileno, pDoc->rs.joinspec[0].rfld) ;
DDATA\uprompt.cpp:#if defined DATADICT_SUPPORT
DDATA\uprompt.cpp:									m_pDataDict ) ;
DDATA\uprompt.cpp:									(CDataDict *)NULL ) ;
DDATA\uprompt.cpp:#if defined DATADICT_SUPPORT
DDATA\uprompt.cpp:									m_pDataDict ) ;
DDATA\uprompt.cpp:									(CDataDict *)NULL ) ;
DFILE\actxedlg.cpp:	CString m_csTmp = m_csInputFileName;
DFILE\actxedlg.cpp:	m_csTmp.MakeLower();
DFILE\actxedlg.cpp:	m_csTmp.TrimLeft();
DFILE\actxedlg.cpp:	m_csTmp.TrimRight();
DFILE\actxedlg.cpp:	if (m_csTmp.Find(".pdi")<0)
DFILE\actxedlg.cpp:		strHTMLFile=m_csTmp+".html";
DFILE\actxedlg.cpp:		strHTMLFile=m_csTmp.Left(m_csTmp.Find(".pdi"))+".html";
DFILE\actxedlg.cpp:	CString m_csTmp = m_csHTMLDoc;
DFILE\actxedlg.cpp:	m_csTmp.MakeLower();
DFILE\actxedlg.cpp:	if (m_csTmp.Find(".htm") < 1)
DFILE\actxedlg.cpp:		char szImgTmp[MAX_URL_LENGTH * 2];
DFILE\actxedlg.cpp:		wsprintf( szImgTmp, szObjectImageParam, m_csImagePath );
DFILE\actxedlg.cpp:		lstrcat( szFullTag, szImgTmp );	// just append
DFILE\actxedlg.cpp:		wsprintf( szImgTmp, szEmbedImageParam, m_csImagePath );
DFILE\actxedlg.cpp:		lstrcat( szEmbed, szImgTmp );	// append image path
DFILE\actxedlg.cpp:	CString m_csTmp = m_csCabinet;
DFILE\actxedlg.cpp:	m_csTmp.MakeLower();
DFILE\actxedlg.cpp:	if ( m_csTmp.Find( "rrprview.cab" ) < 0 )
DFILE\dexport.cpp:#if defined(DATADICT)
DFILE\dfilenew.cpp:static int depressedIcons[] = { IDI_FNWIZD, IDI_FNINSTD, IDI_FNBLANKD, IDI_FNTEMPD, IDI_FNOPEND };
DFILE\dfilenew.cpp:	HICON hIcon = theApp.LoadIcon ( MAKEINTRESOURCE(bSelected ? depressedIcons[nType] : (bFocus ? focusIcons[nType] : normalIcons[nType])) ) ;
DFILE\dfilenew.cpp:				HWND hwndIconButton = ::GetDlgItem ( hDlg, auIcons[nIconID] ) ;
DFILE\dfilenew.cpp:				if ( hwndIconButton )
DFILE\dfilenew.cpp:					::SetWindowPos ( hwndIconButton, NULL, 0, 0, nSystemLargeIconWidth, nSystemLargeIconHeight, SWP_NOMOVE | SWP_NOZORDER | SWP_NOREDRAW ) ;
DFILE\exportActivex.cpp:	CString m_csTmp = m_csHTMLDoc;
DFILE\exportActivex.cpp:	m_csTmp.MakeLower();
DFILE\exportActivex.cpp:	if (m_csTmp.Find(".htm") < 1)
DFILE\exportActivex.cpp:		char szImgTmp[MAX_URL_LENGTH * 2];
DFILE\exportActivex.cpp:		wsprintf( szImgTmp, szObjectImageParam, m_csImagePath );
DFILE\exportActivex.cpp:		lstrcat( szFullTag, szImgTmp );	// just append
DFILE\exportActivex.cpp:		wsprintf( szImgTmp, szEmbedImageParam, m_csImagePath );
DFILE\exportActivex.cpp:		lstrcat( szEmbed, szImgTmp );	// append image path
DFILE\exportActivex.cpp:	CString m_csTmp = m_csCabinet;
DFILE\exportActivex.cpp:	m_csTmp.MakeLower();
DFILE\exportActivex.cpp:	if ( m_csTmp.Find( "rrprview.cab" ) < 0 )
DFILE\htmldlg.cpp:	// Don't let the presence or absense of a trailing slash dictate 
DFILE\mkhtmdlg.cpp:	char szImgTmp[MAX_URL_LENGTH * 2];
DFILE\mkhtmdlg.cpp:		wsprintf( szImgTmp, szObjectImageParam, szImgPath );
DFILE\mkhtmdlg.cpp:		lstrcat( szFullTag, szImgTmp );	// just append
DFILE\mkhtmdlg.cpp:		wsprintf( szImgTmp, szEmbedImageParam, szImgPath );
DFILE\mkhtmdlg.cpp:		lstrcat( szEmbed, szImgTmp );	// append image path
DFILE\RSW\dbtrieve.cpp:static int	GetBtrieveTableList 		(char *pszDictionaryName, HWND hDlg, char * szLastTableName, char * szLastFileName);
DFILE\RSW\dbtrieve.cpp:static void GetBtrieveFileAndTableName	(char *szListEntry, char *szDictionaryName, char *szTableName, char *szDataFileName);
DFILE\RSW\dbtrieve.cpp:static void GetBtrieveDictionary		(char *szDataFile, char *szDictionaryName);
DFILE\RSW\dbtrieve.cpp:static char szCurrentDictionary [_MAX_PATH];
DFILE\RSW\dbtrieve.cpp:static BOOL bDictionaryFirstTry = TRUE;
DFILE\RSW\dbtrieve.cpp:		char TmpChar = szFileAndTable [TABLE_STRING_LIMIT];
DFILE\RSW\dbtrieve.cpp:		szFileAndTable [TABLE_STRING_LIMIT] = TmpChar;
DFILE\RSW\dbtrieve.cpp:// The goal of this procedure is to go through the data dictionary to get
DFILE\RSW\dbtrieve.cpp:	char szDictionaryName [_MAX_PATH];
DFILE\RSW\dbtrieve.cpp:			GetPrivateProfileString (WxBtrieveKey, WxLastDictionary,   getString (IDS_S1082,0), szDictionaryName, _MAX_PATH,		  WxRRInitFile);
DFILE\RSW\dbtrieve.cpp:				Button_SetCheck (::GetDlgItem (hDlg, ID_RADIO_DICTIONARY), 0);
DFILE\RSW\dbtrieve.cpp:	  // If not file, then select dictionary.
DFILE\RSW\dbtrieve.cpp:				Button_SetCheck (::GetDlgItem (hDlg, ID_RADIO_DICTIONARY), 1);
DFILE\RSW\dbtrieve.cpp:	  // Place into the list box the list of tables and files for tihs dictionary
DFILE\RSW\dbtrieve.cpp:			iSaveLastTableIndex = GetBtrieveTableList (szDictionaryName, hDlg, szTableName, getString (IDS_S1082,0));
DFILE\RSW\dbtrieve.cpp:			bDictionaryFirstTry = FALSE;
DFILE\RSW\dbtrieve.cpp:		  // Get the specified dictionary name
DFILE\RSW\dbtrieve.cpp:					_fstrcpy ((LPSTR)szDictionaryName, (LPSTR)szCurrentDictionary);
DFILE\RSW\dbtrieve.cpp:					_splitpath (szDictionaryName,szDrive, szDir, szFileName, szExt);
DFILE\RSW\dbtrieve.cpp:		  // If we are going through the dictionary access method, then start the
DFILE\RSW\dbtrieve.cpp:					if (Button_GetCheck (::GetDlgItem (hDlg, ID_RADIO_DICTIONARY)) == 1)
DFILE\RSW\dbtrieve.cpp:									WH_BTRIEVE_DIC))
DFILE\RSW\dbtrieve.cpp:							lstrcpy ((LPSTR)szDictionaryName, (LPSTR)FileOpenName);
DFILE\RSW\dbtrieve.cpp:							GetBtrieveDictionary (szDataFileName, szDictionaryName);
DFILE\RSW\dbtrieve.cpp:					iSaveLastTableIndex = GetBtrieveTableList (szDictionaryName, hDlg, getString (IDS_S1082,0), szDataFileName);
DFILE\RSW\dbtrieve.cpp:					if (Button_GetCheck (::GetDlgItem (hDlg, ID_RADIO_DICTIONARY)) == 1)
DFILE\RSW\dbtrieve.cpp:					} // end if (Button_GetCheck (::GetDlgItem (hDlg, ID_RADIO_DICTIONARY)) == 1)
DFILE\RSW\dbtrieve.cpp:	  // Get the specified dictionary name
DFILE\RSW\dbtrieve.cpp:					_fstrcpy ((LPSTR)szDictionaryName, (LPSTR)szCurrentDictionary);
DFILE\RSW\dbtrieve.cpp:					GetBtrieveFileAndTableName (szListEntry, szDictionaryName, szTableName, szDataFileName);
DFILE\RSW\dbtrieve.cpp:						WritePrivateProfileString (WxBtrieveKey,WxLastDictionary,	szDictionaryName, WxRRInitFile);
DFILE\RSW\dbtrieve.cpp:// found in the data dictionary defined in lpszDictionaryName
DFILE\RSW\dbtrieve.cpp:static int GetBtrieveTableList (char *pszDictionaryName, HWND hDlg, char * szLastTableName, char * szLastFileName)
DFILE\RSW\dbtrieve.cpp:  // Fill in the last dictionary name (if known)
DFILE\RSW\dbtrieve.cpp:	if (_fstricmp (pszDictionaryName, (LPSTR)getString (IDS_S1082,0)) != 0)
DFILE\RSW\dbtrieve.cpp:	 // For SELCT statement to get the table and file names from the dictionary
DFILE\RSW\dbtrieve.cpp:			(LPSTR)pszDictionaryName);
DFILE\RSW\dbtrieve.cpp:			if (bDictionaryFirstTry == FALSE)
DFILE\RSW\dbtrieve.cpp:		hDCStaticText = ::GetDC (::GetDlgItem (hDlg, ID_STATIC_DICTIONARY));
DFILE\RSW\dbtrieve.cpp:		dwExtent = GetTextExtent (hDCStaticText, (LPSTR)pszDictionaryName, strlen (pszDictionaryName));
DFILE\RSW\dbtrieve.cpp:			iChars = (int) strlen (pszDictionaryName);
DFILE\RSW\dbtrieve.cpp:		::ReleaseDC (::GetDlgItem (hDlg, ID_STATIC_DICTIONARY), hDCStaticText);
DFILE\RSW\dbtrieve.cpp:		::GetWindowRect (::GetDlgItem (hDlg, ID_STATIC_DICTIONARY), &rectStaticText);
DFILE\RSW\dbtrieve.cpp:	// If the length of the dictionary name will not fit into the static field
DFILE\RSW\dbtrieve.cpp:			_splitpath (pszDictionaryName, szDrive, szDir, szFile, szExt);
DFILE\RSW\dbtrieve.cpp:			Edit_SetText (::GetDlgItem (hDlg, ID_STATIC_DICTIONARY), (LPSTR)szTruncatedName);
DFILE\RSW\dbtrieve.cpp:			Edit_SetText (::GetDlgItem (hDlg, ID_STATIC_DICTIONARY), (LPSTR)pszDictionaryName);
DFILE\RSW\dbtrieve.cpp:		_fstrcpy ((LPSTR)szCurrentDictionary, (LPSTR)pszDictionaryName);
DFILE\RSW\dbtrieve.cpp:		// the files and data dictionaries are located in the same directory.
DFILE\RSW\dbtrieve.cpp:				char szTmpDrive [_MAX_DRIVE];
DFILE\RSW\dbtrieve.cpp:				char szTmpDir	[_MAX_DIR];
DFILE\RSW\dbtrieve.cpp:				char szTmpFile	[_MAX_FNAME];
DFILE\RSW\dbtrieve.cpp:				char szTmpExt	[_MAX_EXT];
DFILE\RSW\dbtrieve.cpp:				_splitpath (szCurrentFile, szTmpDrive, szTmpDir, szTmpFile, szTmpExt);
DFILE\RSW\dbtrieve.cpp:				wsprintf ((LPSTR)szCurrentFile, (LPSTR)"%s%s", (LPSTR)szTmpFile, (LPSTR)szTmpExt);
DFILE\RSW\dbtrieve.cpp:				if (stricmp (szTmpExt, "") == 0)
DFILE\RSW\dbtrieve.cpp:	  // Find the matching table entry in the dictionary file
DFILE\RSW\dbtrieve.cpp:	} // end if (stricmp (pszDictionaryName, getString (IDS_S1082,0)) != 0)
DFILE\RSW\dbtrieve.cpp:// name for the data base file. The full path name of the dictionary
DFILE\RSW\dbtrieve.cpp:// path is not given in the data dictionary
DFILE\RSW\dbtrieve.cpp:static void GetBtrieveFileAndTableName (char *szListEntry, char *szDictionaryName, char *szTableName, char *szDataFileName)
DFILE\RSW\dbtrieve.cpp:  // data dictionary
DFILE\RSW\dbtrieve.cpp:  // from the data dictionary path
DFILE\RSW\dbtrieve.cpp:	_splitpath (szDictionaryName,szDrive, szDir, szFileName, szExt);
DFILE\RSW\dbtrieve.cpp:// function GetBtrieveDictionary:
DFILE\RSW\dbtrieve.cpp:// and build a dictionary name from it.
DFILE\RSW\dbtrieve.cpp:// Note: This function assumes that the dictionary file FILE.DDF must
DFILE\RSW\dbtrieve.cpp:static void GetBtrieveDictionary (char * szDataFile, char * szDictionaryName)
DFILE\RSW\dbtrieve.cpp:	wsprintf ((LPSTR)szDictionaryName, (LPSTR)getString (IDS_S1094,0), (LPSTR)szDrive, (LPSTR)szDir, (LPSTR)getString (IDS_S1086,1));
DFILE\RSW\dbtrieve.cpp:  // Check to make sure the data dictionary file is present
DFILE\RSW\dbtrieve.cpp:	if (access (szDictionaryName,0) != 0)
DFILE\RSW\dbtrieve.cpp:		wsprintf ((LPSTR)szMessage, (LPSTR)getString (IDS_S1077,0), (LPSTR)szDictionaryName);
DFILE\RSW\dbtrieve.cpp:} // end GetBtrieveDictionary
DFILE\RSW\dconnect.cpp:			SendDlgItemMessage(hDlg, DBCONDICTPATH, EM_LIMITTEXT, PATHLENGTH,0L);
DFILE\RSW\dconnect.cpp:						GetDlgItemText(hDlg, DBCONDICTPATH, lpszDatabase, PATHLENGTH);
DFILE\RSW\dconnect.cpp:	SetDlgItemText (hDlg, DBCONDICTPATH, "");
DFILE\RSW\dconnect.cpp:			::GetWindowRect (::GetDlgItem (hDlg, DBCONDICTPATHTEXT), &nextFieldRect);
DFILE\RSW\dconnect.cpp:				// Enable datadir and dictdir
DFILE\RSW\dconnect.cpp:			::EnableWindow(::GetDlgItem (hDlg, DBCONDICTPATH), TRUE);
DFILE\RSW\dconnect.cpp:			::ShowWindow (::GetDlgItem (hDlg, DBCONDICTPATH), SHOW_OPENWINDOW);
DFILE\RSW\dconnect.cpp:			::ShowWindow (::GetDlgItem (hDlg, DBCONDICTPATHTEXT), SHOW_OPENWINDOW);
DFILE\RSW\dconnect.cpp:				SetDlgItemText (hDlg, DBCONDICTPATH, logonData->database);
DFILE\RSW\dconnect.cpp:				SetFocus(::GetDlgItem (hDlg, DBCONDICTPATH));
DFILE\RSW\dconnect.cpp:			::GetWindowRect (::GetDlgItem (hDlg, DBCONDICTPATHTEXT), &nextFieldRect);
DFILE\RSW\dconnect.cpp:			::EnableWindow(::GetDlgItem (hDlg, DBCONDICTPATH), FALSE);
DFILE\RSW\dconnect.cpp:			::ShowWindow (::GetDlgItem (hDlg, DBCONDICTPATH), HIDE_WINDOW);
DFILE\RSW\dconnect.cpp:			::ShowWindow (::GetDlgItem (hDlg, DBCONDICTPATHTEXT), HIDE_WINDOW);
DFILE\RSW\dconnect.cpp:			::ShowWindow (::GetDlgItem (hDlg, DBCONDICTPATH), HIDE_WINDOW);
DFILE\RSW\dconnect.cpp:			::ShowWindow (::GetDlgItem (hDlg, DBCONDICTPATHTEXT), HIDE_WINDOW);
DFILE\RSW\dconnect.cpp:		SendDlgItemMessage(hDlg, DCOPYDICTPATH, EM_LIMITTEXT, PATHLENGTH,0L);
DFILE\RSW\dconnect.cpp:				GetDlgItemText(hDlg, DCOPYDICTPATH, Copy_path, PATHLENGTH);
DFILE\RSW\dconnect.cpp:	SetDlgItemText (hDlg, DCOPYDICTPATH, "");
DFILE\RSW\dconnect.cpp:	::EnableWindow(::GetDlgItem (hDlg, DCOPYDICTPATH),
DFILE\RSW\dconnect.cpp:	::ShowWindow (::GetDlgItem (hDlg, DCOPYDICTPATH),
DFILE\RSW\dconnect.cpp:	::ShowWindow (::GetDlgItem (hDlg, DCOPYDICTPATHTEXT),
DFILE\RSW\dconnect.cpp:		SetDlgItemText (hDlg, DCOPYDICTPATH,
DFILE\RSW\dconnect.cpp:			platform == (unsigned char)Copy_platform ?	Copy_dpath : Defs.szXQLDictPath);
DFORMAT\dfmod.cpp:// Added code from Abra branch, conditional on DATADICT that disables the
DFORMAT\dfmod.cpp:			setImagePalette  ( FALSE ) ;  // say 7/13/93  Re-set flag indicating whether we have colorful images.
DFORMAT\fcomment.cpp:	else // hide data dictionary help text
DINSERT\dinsfld.cpp:		case DICLOSEDLG:
DINSERT\dinsfld.cpp:				pDoc->CloseInsDlg = (BOOL)::SendDlgItemMessage(hDlg, DICLOSEDLG, BM_GETCHECK, 0, 0L);
DINSERT\dinsfld.cpp:			case DICLOSEDLG:
DINSERT\dinsfld.cpp:					pDoc->CloseInsDlg = (BOOL)::SendDlgItemMessage(hDlg, DICLOSEDLG, BM_GETCHECK, 0, 0L);
DINSERT\dinsfld.cpp:		case DICLOSEDLG:
DINSERT\dinsfld.cpp:				pDoc->CloseInsDlg = (BOOL)::SendDlgItemMessage(hDlg, DICLOSEDLG, BM_GETCHECK, 0, 0L);
DINSERT\dinsfld.cpp:		case DICLOSEDLG:
DINSERT\dinsfld.cpp:				pDoc->CloseInsDlg = (BOOL)::SendDlgItemMessage(hDlg, DICLOSEDLG, BM_GETCHECK, 0, 0L);
DINSERT\dinsfld.cpp:	DDX_Check(pDX, DICLOSEDLG, CloseAfterInsert) ;
DINSERT\dinsfld.cpp:		hdlCkbxClz = *GetDlgItem(DICLOSEDLG);
DMISC\dmess.cpp:	HWND hwndIcon = ::GetDlgItem (hDlg, DMICON) ;
DMISC\dmess.cpp:	ASSERT( hwndIcon );
DMISC\dmess.cpp:	::GetWindowRect (hwndIcon, &rectIcon);
DOPTIONS\dfileset.cpp:// Remove Dictionary folder settings
DOPTIONS\dfileset.cpp://	CEdit*  pwndReportDictionary  = (CEdit*) GetDlgItem ( IDC_FILESETTINGS_REPORT_DICTIONARY  ) ;
DOPTIONS\dfileset.cpp://	CEdit*  pwndDictionaryIndex   = (CEdit*) GetDlgItem ( IDC_FILESETTINGS_DICTIONARY_INDEX   ) ;
DOPTIONS\dfileset.cpp://	ASSERT( pwndReportDictionary  ) ;
DOPTIONS\dfileset.cpp://	ASSERT( pwndDictionaryIndex   ) ;
DOPTIONS\dfileset.cpp://	pwndReportDictionary->LimitText  ( WINPATHLEN ) ;
DOPTIONS\dfileset.cpp://	pwndDictionaryIndex->LimitText   ( WINPATHLEN ) ;
DOPTIONS\dfileset.cpp://	CString csReportDictionary  = m_szReportDictionary  ;
DOPTIONS\dfileset.cpp://	CString csDictionaryIndex   = m_szDictionaryIndex   ;
DOPTIONS\dfileset.cpp://	DDX_Text    (pDX, IDC_FILESETTINGS_REPORT_DICTIONARY,  csReportDictionary ) ;
DOPTIONS\dfileset.cpp://	DDX_Text    (pDX, IDC_FILESETTINGS_DICTIONARY_INDEX,   csDictionaryIndex  ) ;
DOPTIONS\dfileset.cpp://	strcpy ( m_szReportDictionary  , csReportDictionary  ) ;
DOPTIONS\dfileset.cpp://	strcpy ( m_szDictionaryIndex   , csDictionaryIndex   ) ;
DOPTIONS\dfileset.cpp://	ON_BN_CLICKED(IDC_FILESETTINGS_REPORT_DICTIONARY_BROWSE, OnFileSettingsReportDictionaryBrowse)
DOPTIONS\dfileset.cpp://	ON_BN_CLICKED(IDC_FILESETTINGS_DICTIONARY_INDEX_BROWSE,  OnFileSettingsDictionaryIndexBrowse )
DOPTIONS\dfileset.cpp://	LPSTR  files[]     = { m_szReportDictionary, m_szDictionaryIndex, NULL } ;
DOPTIONS\dfileset.cpp://void CFileSettingsDialog::OnFileSettingsReportDictionaryBrowse() 
DOPTIONS\dfileset.cpp://	m_pDoc->browse   ( GetSafeHwnd(), IDC_FILESETTINGS_REPORT_DICTIONARY,  m_szDataDirectory,     m_pDoc->ldatadir, TRUE,  IDS_0206, 0,        WxDBFExt,           IDS_1133 ) ;
DOPTIONS\dfileset.cpp://	::GetDlgItemText ( GetSafeHwnd(), IDC_FILESETTINGS_REPORT_DICTIONARY,  m_szDataDirectory,     WINPATHLEN ) ;
DOPTIONS\dfileset.cpp://void CFileSettingsDialog::OnFileSettingsDictionaryIndexBrowse() 
DOPTIONS\dfileset.cpp://	m_pDoc->browse   ( GetSafeHwnd(), IDC_FILESETTINGS_DICTIONARY_INDEX,   m_szDataDirectory,     m_pDoc->ldatadir, TRUE,  IDS_0207, IDC_FILESETTINGS_INDEX_EXTENSION, m_szIndexExtension, IDS_1134 ) ;
DOPTIONS\dfileset.cpp://	::GetDlgItemText ( GetSafeHwnd(), IDC_FILESETTINGS_DICTIONARY_INDEX,   m_szDataDirectory,     WINPATHLEN ) ;
DOPTIONS\dfileset.cpp:	// no good if one data dict file and not the other
DOPTIONS\dfileset.cpp:	else if ( (strlen(m_szReportDictionary) && !strlen(m_szDictionaryIndex)) || (!strlen(m_szReportDictionary) && strlen(m_szDictionaryIndex)) )
DOPTIONS\dglobdef.cpp:// Remove dictionary folder settings
DOPTIONS\dglobdef.cpp:// Added "Report dictionary requires a table and an index file"
DOPTIONS\dglobdef.cpp:// Added "Template Library," "Data Dictionary," and "Dictionary Index"
DOPTIONS\dglobdef.cpp:#include "datadict.h"		// for DDFName, DDIName, & WxData*
DOPTIONS\dglobdef.cpp:	WritePrivateProfileString(WxDictKey,WxDataDict,    theApp.Paths->DDFName,theApp.m_elmFileManager.GetRRInitFile());
DOPTIONS\dglobdef.cpp:	WritePrivateProfileString(WxDictKey,WxDataDictIx,  theApp.Paths->DDIName,theApp.m_elmFileManager.GetRRInitFile());
DOPTIONS\dglobdef.cpp://	strcpy ( dlgFileSettings.m_szReportDictionary,  theApp.Paths->DDFName ) ;
DOPTIONS\dglobdef.cpp://	strcpy ( dlgFileSettings.m_szDictionaryIndex,   theApp.Paths->DDIName ) ;
DOPTIONS\dglobdef.cpp://		strcpy ( theApp.Paths->DDFName, dlgFileSettings.m_szReportDictionary  ) ;
DOPTIONS\dglobdef.cpp://		strcpy ( theApp.Paths->DDIName, dlgFileSettings.m_szDictionaryIndex   ) ;
DOPTIONS\dpref.cpp://  lists should contain field names, data-dictionary descriptions, or
ENG\RSW\dbi.cpp:// Change to DBIunquote() for dictionary
ENG\RSW\dbi.cpp:// runtime QEDATADICTEXTENSIONS code
ENG\RSW\dbi.cpp:// update registry for QEDATADICTEXTENSIONS
ENG\RSW\dbi.cpp:// get qedatadictextension from registry for qelib 2.10
ENG\RSW\dbi.cpp://  QEDATADICTEXTENSIONS=1, since old QELIB 2.0.3 looks there)
ENG\RSW\dbi.cpp:// include odbcjt32 in list of MS text drivers (for QEDATADICTEXTENSIONS test
ENG\RSW\dbi.cpp:// 1) also check for odbcjt16 text driver needing QEDATADICT...
ENG\RSW\dbi.cpp:// Be fussy about needing QEDATADICTEXTENSIONS=1 for MSText driver
ENG\RSW\dbi.cpp:// which has an ODBC.INI setting which indicates what the underlying database
ENG\RSW\dbi.cpp:			SQLGetPrivateProfileString(newSource->szName,"QEDATADICTEXTENSIONS", "",value,19, theApp.m_elmFileManager.GetODBCInitFile());
ENG\RSW\dbi.cpp:					SQLWritePrivateProfileString(newSource->szName,"QEDATADICTEXTENSIONS", "1", theApp.m_elmFileManager.GetODBCInitFile());
ENG\RSW\dbi.cpp:				SQLWritePrivateProfileString(newSource->szName,"QEDATADICTEXTENSIONS", "1", theApp.m_elmFileManager.GetODBCInitFile());
ENG\RSW\dbi.cpp:	// XXX warn if DS name is "Default" vs. input name, indicating not found
ENG\RSW\dbi.cpp:	// XXX warn if DS name is "Default" vs. input name, indicating not found
ENG\RSW\iengflds.cpp:	BOOL bFakeFailure = TRUE; // indicates if success on executing stored
ENG\RSW\iengflds.cpp:	MFFiles[fileno]->mFlags2 |= MFALL; /* indicates that we can do
ENG\RSW\iengine.cpp://  doesn't have a quote character.  sql_prep_tablename_for_dict() hangs.
ENG\RSW\iengine.cpp:// Added sql_prep_tablename_for_dict() as part of fix for RSW bug 1527.
ENG\RSW\iengine.cpp://  Other changes are in eng.h and datadict.c.  Also by Steve in wiz.c.
ENG\RSW\iengine.cpp:LPSTR CRrComposite::sql_prep_tablename_for_dict (LPSTR lpszNameIn, LPSTR lpszNameOut)
ENG\RSW\ienglog.cpp:// bSelect indicates whether OK button should say "Select" or "Close"
ENG\RSW\iengmenu.cpp://	bNoSystem - flag indicates whether to list system tables or non-system tables.
ENG\RSW\iengmenu.cpp:		// disable dictionary button
ENG\RSW\iengmenu.cpp:		::ShowWindow (::GetDlgItem (hDlg, IDDICT),  SW_HIDE);
ENG\RSW\iengmenu.cpp:				case IDDICT:
ENG\RSW\iengmenu.cpp:	CRect	rectCmdDict;
ENG\RSW\iengmenu.cpp:	HWND	hdlCmdDict;
ENG\RSW\iengmenu.cpp:						hdlCmdDict = GetDlgItem(hDlg, IDDICT);
ENG\RSW\iengmenu.cpp:						::GetWindowRect(hdlCmdDict, &rectCmdCopy);
ENG\RSW\iengmenu.cpp:				case IDDICT:
ENG\RSW\iengmenu.cpp:						// If Oracle, an owner name of "public" indicates a publicly-defined
ENG\RSW\iengparm.cpp:// Tokens are separated by commas.	Null data between commas indicates that
ENG\RSW\iengparm.cpp:// Ex: <<repl1>>,,,<<repl4>>   indicates that the 1st and 4th parameters
ENG\RSW\iengparm.cpp:// are to be replaced.	Not-to-be-replaced tokens are indicated by a
ENG\RSW\iengparm.cpp:	static LPSTR lpszOrig, lpszLeft, lpszRight, lpszTmp;
ENG\RSW\iengparm.cpp:		lpszTmp = _fstrchr (lpszLeft, cLeftDelim);
ENG\RSW\iengparm.cpp:		if (!lpszTmp)
ENG\RSW\iengparm.cpp:			lpszLeft = lpszTmp;
ENG\RSW\iengparm.cpp:	LPSTR tmpParamList, lpszReturn;
ENG\RSW\iengparm.cpp:		tmpParamList = m_pDoc->globalAlloc(GMEM_FIXED, _fstrlen(lpszParamList) +1);
ENG\RSW\iengparm.cpp:		if (!tmpParamList)
ENG\RSW\iengparm.cpp:		_fstrcpy (tmpParamList, lpszParamList);
ENG\RSW\iengparm.cpp:		if (!getToken(LPARAM_CHAR, RPARAM_CHAR, 2, tmpParamList,&params[0]))
ENG\RSW\iengparm.cpp:			m_pDoc->globalFree (tmpParamList);
ENG\RSW\iengparm.cpp:			m_pDoc->globalFree (tmpParamList);
ENG\RSW\iengparm.cpp:		m_pDoc->globalFree (tmpParamList);
EXPORTMG\CALLBACK\crstabif.cpp:	// If there was an error loading the DLL indicate this
EXPORTMG\CALLBACK\crstabif.cpp:			// Allocate a bunch of tmp strings for the splitpath function
EXPORTMG\CALLBACK\crstabif.cpp:			// Free up all this tmp stuff
EXPORTMG\DLG\rrxtab.cpp:// added a dirty flag to indicate if we really need to save the information
EXPORTMG\DLG\rrxtab.cpp:	lpGlobalXTAB_Info->xPrint = xPrint;	// Indicate if printing should happen
EXPORTMG\DLG\xtabdlg.cpp:// added a dirty flag to indicate if we really need to save the 
EXPORTMG\DLG\xtabdlg.cpp:BOOL BuildTmpFileName (LPXTABINFO lpXTAB_Info);
EXPORTMG\DLG\xtabdlg.cpp:// BOOL bDoExport					This indicates if we are here from the OK
EXPORTMG\DLG\xtabdlg.cpp:	BuildTmpFileName (XTAB_Info);	// First, generate a tmp file
EXPORTMG\DLG\xtabdlg.cpp:// Function BuildTmpFileName
EXPORTMG\DLG\xtabdlg.cpp:BOOL BuildTmpFileName (LPXTABINFO lpXTAB_Info)
EXPORTMG\DLG\xtabdlg.cpp:	char szTmp [_MAX_PATH];
EXPORTMG\DLG\xtabdlg.cpp:	GetTempPath(_MAX_PATH,szTmp);
EXPORTMG\DLG\xtabdlg.cpp:	GetTempFileName (szTmp, cTemp1, 0, lpXTAB_Info->szTempExportName);
EXPORTMG\DLG\xtabdlg.cpp:	strcpy (szTmp, lpXTAB_Info->szTempExportName);
EXPORTMG\DLG\xtabdlg.cpp:	_unlink (szTmp);	// get rid of old one
EXPORTMG\DLG\xtabdlg.cpp:} // end BuildTmpFileName
EXPORTMG\DLG\xtabdlg.cpp:	// Allocate a local tmp buffer of size alias buffer + field buffer
EXPORTMG\DLG\xtabdlg.cpp:	PSTR lpszTmpBuffer = new char [strlen (lpszAliasBuffer)
EXPORTMG\DLG\xtabdlg.cpp:	wsprintf (lpszTmpBuffer, "%s\n%s\n", lpszAliasBuffer, szFieldBuffer);
EXPORTMG\DLG\xtabdlg.cpp:	strcat (lpXTAB_Info->szListBuffer, lpszTmpBuffer);
EXPORTMG\DLG\xtabdlg.cpp:		+ strlen (lpszTmpBuffer);
EXPORTMG\DLG\xtabdlg.cpp:	delete[] lpszTmpBuffer;	// Delete this tmp buffer for this routine
EXPORTMG\FLDLST\fldlst.cpp:// changed to support data dict. extra data item
EXPORTMG\FLDLST\fldlst.cpp:// to update the field list state to indicate that an alias list may be
EXPORTMG\FLDLST\fldobj.cpp://  changed to support data dict. extra data item
EXPORTMG\FLDLST\tblobj.cpp://  changed to support data dict. extra data item
EXPORTMG\FLDLST\tblobj.cpp:	bExpanded = TRUE;	// Indicate that it is not expanded. This is the initial state.
EXPORTMG\FLDLST\usrobj.cpp://  changed to support data dict. extra data item
FILTER\pksx.cpp:					if (valcnt==0) mt1 = TRUE;	/* types okay, indicate emptiness */
FILTER\RRW\sxeeval.cpp:	   allow wildcards in the second field.  lzmatch() only indicates whether
FILTER\sxparse.cpp:			/* AND, OR, LISTEQ, LISTNE all take a length indicator
FILTER\sxparse.cpp:		} /*length indicator*/
FILTER\sxreject.cpp:	   allow wildcards in the second field.  zmatch() only indicates whether
INDEX\klfiles.cpp:   int nsx = FALSE;  /* flag indicating SuccessWare NSX file */
INDEX\klfiles.cpp:            // tho only used for NSX indices.
INDEX\klfiles.cpp:      // tho only used for NSX indices.
LIBIO\libdir.cpp://  Sets m_pLibFile to NULL to indicate no current LIBFile.
LIBIO\libfile.cpp://  Initializes file handle to CFile::hFileNull to indicate that
LIBIO\libfile.cpp://  It initializes the free-chain head and current chunk number to 0, indicating
LIBIO\libfile.cpp: BOOL bRewriteFlag		// flag indicating we're rewriting a chain
LIBIO\yz.cpp:	LPYZNAME yzntmp = yzn;
LIBIO\yz.cpp:		{	yz_add(yzntmp); 				/* add a name */
LIBIO\yz.cpp:			yzntmp = yzntmp->yznLk; 		/* on to next one */
LIBIO\yz.cpp:	{	yzntmp = yzn->yznLk;			/* remember address of next one */
LIBIO\yz.cpp:		yzn = yzntmp;
LIBIO\yz.cpp:	LPYZNAME yzntmp;
LIBIO\yz.cpp:				|| (!(yzntmp = (LPYZNAME)globalAlloc (GHND, sizeof(YZNAME) + yz_hdr[0]))))
LIBIO\yz.cpp:				yzntmp = yzn->yznLk;		/* remember link */
LIBIO\yz.cpp:				yzn = yzntmp;				/* on to next one */
LIBIO\yz.cpp:			yzntmp->yznLk = NULL;				/* null link, since at end */
LIBIO\yz.cpp:			yzntmp->yznChNo = *(FOUR *)(yz_hdr+1);	/* fill in chunk number */
LIBIO\yz.cpp:			yzntmp->yznStamp = NULL;
LIBIO\yz.cpp:			yzntmp->yznNote = NULL;			// report annotation
LIBIO\yz.cpp:			((CRrApp*)AfxGetApp())->lzmemcpy(yzntmp->yznName,buf,yz_hdr[0]);	/*	and name */
LIBIO\yz.cpp:			yzntmp->yznName[yz_hdr[0]] = 0; 	/*	and null terminator */
LIBIO\yz.cpp:				yznend->yznLk = yzntmp; 		/* yep, add to end */
LIBIO\yz.cpp:				yznend = yzntmp;				/* remember new end */
LIBIO\yz.cpp:				yzn = yznend = yzntmp;			/* this one is head & end */
LIBIO\yz.cpp:			globalFree ((LPSTR)yzntmp);
MFDATA\memo.cpp:			/* We will get passed in a memo_id (a pointer which indicates 
MFDATA\mfgetrec.cpp:						m_pDoc->getTempFileName("TMP",MFSortFile);
MFDATA\mfrdmore.cpp:	savepm = prevmem;	/* save indicator of prev(memo) */
MFDATA\mfrdmore.cpp:	prevmem = savepm;	/* restore prev(memo) indicator */
MFDATA\mfrdrec.cpp:// Added code from Abra branch, conditional on DATADICT, that allows for
MFDATA\mfrdrec.cpp:#if defined(DATADICT)
MFDATA\mfrdrec.cpp:#include "datadict.h"	// for DDRecordSecurity
MFDATA\mfwrfin.cpp:		fld->dFlags2 &= ~f2GOTFIN;	/* clear indicator */
MFDATA\mfwrfin.cpp:			fld->dFlags2 |= f2GOTFIN;		/* set indicator */
MFDATA\RRW\mfrdnext.cpp:// Added code from Abra branch, conditional on DATADICT, that allows for
MFDATA\RRW\mfrdnext.cpp:#include "datadict.h"	// for DDRecordSecurity
MFDATA\RRW\rdahead.cpp:		if (!(sb->sTmpP=m_pDoc->globalAlloc(GMEM_MOVEABLE,bs)))
MFDATA\RRW\rdahead.cpp:	else sb->sTmpP = NULL;
MFDATA\RRW\rdahead.cpp:			if (sb->sTmpP) m_pDoc->globalFree(sb->sTmpP);
MFDATA\RRW\rdahead.cpp:		if (fld->dSS->sTmpP) m_pDoc->globalFree(fld->dSS->sTmpP);
MFDATA\RRW\rdahead.cpp:				tb = fld->dSS->sTmpP;
MFDATA\RRW\rdahead.cpp:			if (tb) lmemcpy(fld->dSS->sTmpP,tb,SIZE(tb)); /*copy temp data*/
MFDATA\RRW\rdahead.cpp:				tb = fld->dSS->sTmpP;
MFDATA\RRW\rdahead.cpp:				lmemcpy(tb,fld->dSS->sTmpP,SIZE(tb)); /* copy temp data */
MFDATA\RSW\mfsql.cpp:	// First build the reltab array which indicates prerequisites
MFDATA\RSW\mfsql.cpp:unsigned int	eng;	// flag indicating a engine eval expression
MFDATA\RSW\mfsql.cpp:		// Have to use tmpstr because getString has only 2 buffers
MFDATA\RSW\mfsql.cpp:		// Have to use tmpstr because getString has only 2 buffers
MFDATA\RSW\mfsql.cpp:int			cht;	// flag indicating a character sort field
MFDATA\RSW\mfsql.cpp:int			makeflat;	// flag indicating need LowerOpen/Close on sort field
MFDATA\RSW\mfsql.cpp:		CString sTmpUserSelect = sUserSelect; //162947 don't uppercase the cols name
MFDATA\RSW\mfsql.cpp:		sTmpUserSelect.MakeUpper();
MFDATA\RSW\mfsql.cpp:		int iFromOffset = sTmpUserSelect.Find("FROM ");
MFDATA\RSW\mfsql.cpp:			CString strTmpFromClause = strFromClause; //162947
MFDATA\RSW\mfsql.cpp:			strTmpFromClause.MakeUpper();
MFDATA\RSW\mfsql.cpp:			int iWhereOffset = strTmpFromClause.Find("WHERE");
MFDATA\RSW\mfsql.cpp:			int iGroupByOffset = strTmpFromClause.Find("GROUP BY");
MFDATA\RSW\mfsql.cpp:			int iHavingOffset = strTmpFromClause.Find("HAVING");
MFDATA\RSW\mfsql.cpp:			int iAfterFromClauseOffset = strTmpFromClause.GetLength();
MFDATA\RSW\mfsql.cpp:					CString strTmp = strFromClause;
MFDATA\RSW\mfsql.cpp:					CString strWk = strTmp.SpanExcluding(",");
MFDATA\RSW\mfsql.cpp:					strFromClause = strTmp.Right(strTmp.GetLength()-strWk.GetLength()-1);
MFEDIT\fileline.cpp:			strcat(st,"...");   // indicate multicolumn join
MFEDIT\fileline.cpp:			strcat(st,"...");   // indicate multicolumn join
MFEDIT\mfdelcon.cpp:		strSuffix.LoadString( T3aMFDC );	// "The indicated charts..."
MFFIELD\mfcalc.cpp:// Finishes (?) the fixing of RRW bug 2407 (see datadict.c 1.26 for
MFFIELD\mfcalc.cpp:// More stuff related to RR bug 1968.  See datadict.c 1.13 for details.
MFFIELD\mfcalc.cpp://  from data-dictionary code than when called from instant-report code.
MFFIELD\mfcalc.cpp://  Also changed datadict.c, winst.c, mffield.h to adjust callers of mfcalc.
MFFIELD\mfcalc.cpp:			  BOOL fromdd,				// called from data-dict code; hide most fields, if TRUE
MFFIELD\mfcalc.cpp:	// if called from data dictionary code, try "local" compile first, since only
MFFIELD\mfcalc.cpp:		return NULL;	// not from data-dict code, compile failed
MFFIELD\mfcalc.cpp:	if (!fromdd)			// not called from data dict code, so eord as always
MFFIELD\mfrlsfld.cpp:// Added code from Abra branch, conditional on DATADICT, to free the "comment"
MFFIELD\mfrlsfld.cpp:// Added DATADICT conditional around release of ->comment memory.
MFFIELD\mfrlsfld.cpp:// 					MFONOUPD bit means "don't update saved mf field indices"
MFFIELD\mfrlsfld.cpp:#if defined(DATADICT)
MFFIELD\mfxfld.cpp:// new funtion to indicate if an export really occured
MFFIELD\mfxfld.cpp:// fixed problem exporting data with data dict support
MFFIELD\mfxfld.cpp:	// Reset the flag indicating that an export just occured
MFFIELD\mfxfld.cpp:	//		indicate character type, so we need separate flag
MFFIELD\mfxfld.cpp:// This function will return an indication if the add-on export command was issued
MFFILE\mfchgfil.cpp:// All within RSW conditionals for support of data dictionary.
MFFILE\mfchgfil.cpp://  Complex support for "predefined" calcs from data dictionary, which is
MFFILE\mfchgfil.cpp://   conditional on DATADICT.
MFFILE\mfchgfil.cpp:#if defined(DATADICT)
MFFILE\mfchgfil.cpp:#if defined(DATADICT)
MFFILE\mfchgfil.cpp:#if defined(DATADICT)
MFFILE\mfchgfil.cpp:#if defined(DATADICT)
MFFILE\mfchgfil.cpp:	((CRrApp *)AfxGetApp())->DDChangeFile = FALSE;		// clear data-dictionary change-file flag
MFFILE\mfchgfil.cpp: #if defined(DATADICT)
MFFILE\mfchgfil.cpp:							tf->dRecU.calcS.dTmpLnk = (LPSTR)compileMe;
MFFILE\mfchgfil.cpp:							tf->dRecU.calcS.dTmpLnk = NULL;
MFFILE\mfchgfil.cpp:#if defined(DATADICT)
MFFILE\mfchgfil.cpp:									tf->dRecU.calcS.dTmpLnk = (LPSTR)compileMe;
MFFILE\mfchgfil.cpp:									tf->dRecU.calcS.dTmpLnk = NULL;
MFFILE\mfchgfil.cpp:									tf->dRecU.calcS.dTmpLnk = (LPSTR)compileMe;
MFFILE\mfchgfil.cpp:									tf->dRecU.calcS.dTmpLnk = NULL;
MFFILE\mfchgfil.cpp:#if defined(DATADICT)
MFFILE\mfchgfil.cpp:				tf->dRecU.calcS.dTmpLnk = (LPSTR)compileMe;
MFFILE\mfchgfil.cpp:				tf->dRecU.calcS.dTmpLnk = NULL;
MFFILE\mfchgfil.cpp:#if defined(DATADICT)
MFFILE\mfchgfil.cpp:		compileMe = (LPMFFIELD)compileMe->dRecU.calcS.dTmpLnk;
MFFILE\mfchgfil.cpp:#if defined(DATADICT)
MFFILE\mfchgfil.cpp:#if defined(DATADICT)
MFFILE\mfchgfil.cpp:#if defined(DATADICT)
MFFILE\mfchgfil.cpp:	((CRrApp *)AfxGetApp())->DDChangeFile = TRUE;		// set data-dictionary change-file flag
MFFILE\mfchgfil.cpp:#if defined(DATADICT)
MFFILE\mfchgfil.cpp:	((CRrApp *)AfxGetApp())->DDChangeFile = TRUE;		// set data-dictionary change-file flag
MFFILE\mfchgfil.cpp:#if defined(DATADICT)
MFFILE\mfchgfil.cpp:	((CRrApp *)AfxGetApp())->DDChangeFile = FALSE;		// clear data-dictionary change-file flag
MFFILE\mfdbf.cpp:// Bug on Add to Dict. field
MFFILE\mfdbf.cpp:// Data dict stuff
MFFILE\mfdbf.cpp:// Show correct table when adding calc. to dict.
MFFILE\mfdbf.cpp:// Deferred dict. attribute; crash on non-file field
MFFILE\mfdbf.cpp:// Update dictionary procedures
MFFILE\mfdbf.cpp:// calcs from data dict even though not calling mfopen().
MFFILE\mfdbf.cpp:			((CRrApp *)AfxGetApp())->ddsetup_nomaster();		// get eval-once calcs from data dict
MFFILE\mfdbf.cpp:		UpdateDictionaryFile(0, NULL) ;
MFFILE\mfdbf.cpp:// Update the dictionary for a file
MFFILE\mfdbf.cpp:void CRrComposite::UpdateDictionaryFile(int fno, char *IndexExpression)
MFFILE\mfdbf.cpp:	if (!m_pDoc->Defs.Dictionary)
MFFILE\mfdbf.cpp:	if (!UpdateDictionaryInit())
MFFILE\mfdbf.cpp:	UpdateDictionaryWriteLine(_strupr(table)) ;
MFFILE\mfdbf.cpp:	UpdateDictionaryWriteLine("S") ;
MFFILE\mfdbf.cpp:		UpdateDictionaryWriteLine(ActiveDS->szName) ;
MFFILE\mfdbf.cpp:		UpdateDictionaryWriteLine(DBIgetNADataSource(mffileP->mDataSourceOff));
MFFILE\mfdbf.cpp:	UpdateDictionaryWriteLine("X") ;
MFFILE\mfdbf.cpp:		UpdateDictionaryWriteLine(buf) ;
MFFILE\mfdbf.cpp:		// Now insert the attributes from the dictionary, if any
MFFILE\mfdbf.cpp:			if (fld->dict.dLength != 0)
MFFILE\mfdbf.cpp:				fld->dLength = fld->dict.dLength ;
MFFILE\mfdbf.cpp:			if (fld->dict.dFldPic != 0)
MFFILE\mfdbf.cpp:				fld->dFldPic = fld->dict.dFldPic ;
MFFILE\mfdbf.cpp:			if (fld->dict.dDecPl != 0)
MFFILE\mfdbf.cpp:				fld->dDecPl = fld->dict.dDecPl - 1 ;
MFFILE\mfdbf.cpp:			switch (fld->dict.align)
MFFILE\mfdbf.cpp:	UpdateDictionaryLaunch("ddfldup") ;
MFFILE\mfdbf.cpp:	if (!UpdateDictionaryInit())
MFFILE\mfdbf.cpp:	UpdateDictionaryWriteLine(table) ;
MFFILE\mfdbf.cpp:	UpdateDictionaryWriteLine(_strupr(index)) ;
MFFILE\mfdbf.cpp:	UpdateDictionaryWriteLine(IndexExpression) ;
MFFILE\mfdbf.cpp:	UpdateDictionaryWriteLine(buf) ;
MFFILE\mfdbf.cpp:	UpdateDictionaryWriteLine(buf) ;
MFFILE\mfdbf.cpp:	UpdateDictionaryWriteLine(buf) ;
MFFILE\mfdbf.cpp:	UpdateDictionaryLaunch("ddidxup") ;
MFFILE\mfdbf.cpp:void CRrComposite::UpdateDictionaryCalcField(LPMFFIELD f)
MFFILE\mfdbf.cpp:	if (!m_pDoc->Defs.Dictionary)
MFFILE\mfdbf.cpp:	if (!UpdateDictionaryInit())
MFFILE\mfdbf.cpp:	UpdateDictionaryWriteLine(_strupr(table)) ;
MFFILE\mfdbf.cpp:	UpdateDictionaryWriteLine(fieldName) ;
MFFILE\mfdbf.cpp:	UpdateDictionaryWriteLine(ActiveDS->szName) ;
MFFILE\mfdbf.cpp:	UpdateDictionaryWriteLine("") ;
MFFILE\mfdbf.cpp:		UpdateDictionaryWriteLine(f->comment) ;
MFFILE\mfdbf.cpp:		UpdateDictionaryWriteLine("") ;
MFFILE\mfdbf.cpp:	UpdateDictionaryWriteLine(buffer) ;
MFFILE\mfdbf.cpp:	UpdateDictionaryWriteLine(buffer) ;
MFFILE\mfdbf.cpp:	UpdateDictionaryWriteLine(buffer) ;
MFFILE\mfdbf.cpp:		UpdateDictionaryWriteLine(line) ;
MFFILE\mfdbf.cpp://	UpdateDictionaryWriteLine(f->dRecU.calcS.dExpD) ;
MFFILE\mfdbf.cpp:	UpdateDictionaryLaunch("dcalcup") ;
MFFILE\mfdbf.cpp:bool CRrComposite::UpdateDictionaryInit()
MFFILE\mfdbf.cpp:	GetTempFileName(tempDir, "dict", 0, path) ;
MFFILE\mfdbf.cpp:	UpdateDictionaryWriteLine(m_pDoc->OwnerId) ;
MFFILE\mfdbf.cpp:void CRrComposite::UpdateDictionaryWriteLine(char *line)
MFFILE\mfdbf.cpp:void CRrComposite::UpdateDictionaryLaunch(char *program)
MFFILE\mfmemfld.cpp:	MFANamedMemos = names;		/* an indication for editascii */
MFFILE\mfopen.cpp:// use alias from dict. for SQL, too
MFFILE\mfopen.cpp:// use alias from dictionary
MFFILE\mfopen.cpp:// to put db override stuff in ARP tmp
MFFILE\mfopen.cpp://  WO 159630 (modified port of TMP for WO 156383)
MFFILE\mfopen.cpp://  dictionary or index result in "no supported fields" errors.
MFFILE\mfopen.cpp://  data-dictionary support.
MFFILE\mfopen.cpp://  match RRW mechanism, which was changed for data-dictionary support.
MFFILE\mfopen.cpp:// Put conditional on DATADICT around ddsetup(), ddrelease() calls in
MFFILE\mfopen.cpp:// Added call to ddsetup() to process data-dictionary info for newly opened
MFFILE\mfopen.cpp:#include "datadict.h"
MFFILE\mfopen.cpp:		if (theApp.ddAlias(name, aliasbuf))	// see if have alias in dictionary
MFFILE\mfopen.cpp:	if (theApp.ddAlias(p, aliasbuf))// see if have alias in dictionary
MFFILE\mfopen.cpp:	char *newalias)		// mAlias value or NULL (for data dict code)
MFFILE\mfopen.cpp:	char *newalias)		// mAlias value or NULL (for data dict code)
MFFILE\mfopen.cpp:	mffileP->mFlags2 &= ~MFOLDFLAT; /* clear indicator */
MFFILE\mfopen.cpp: #if defined(DATADICT)
MFFILE\mfopen.cpp:	if (pApp->ddsetup(&mffirstfld,mffileP->mAlias,filno))	/* set up the data dictionary info. */
MFFILE\mfopen.cpp:	// clear indicators
MFFILE\mfopen.cpp: #if defined(DATADICT)
MFFILE\mfopen.cpp:	if (pApp->ddsetup(&mffirstfld,mffileP->mAlias,filno))	// set up the data dictionary info.	// tom le this is where db file is opened
MFFILE\olfmfopen.cpp://  dictionary or index result in "no supported fields" errors.
MFFILE\olfmfopen.cpp://  data-dictionary support.
MFFILE\olfmfopen.cpp://  match RRW mechanism, which was changed for data-dictionary support.
MFFILE\olfmfopen.cpp:// Put conditional on DATADICT around ddsetup(), ddrelease() calls in
MFFILE\olfmfopen.cpp:// Added call to ddsetup() to process data-dictionary info for newly opened
MFFILE\olfmfopen.cpp:#include "datadict.h"
MFFILE\olfmfopen.cpp:char *newalias)	// mAlias value or NULL (for data dict code)
MFFILE\olfmfopen.cpp:		char *newalias)	// mAlias value or NULL (for data dict code)
MFFILE\olfmfopen.cpp:	mffileP->mFlags2 &= ~MFOLDFLAT; /* clear indicator */
MFFILE\olfmfopen.cpp: #if defined(DATADICT)
MFFILE\olfmfopen.cpp:	if (pApp->ddsetup(&mffirstfld,mffileP->mAlias,filno))	/* set up the data dictionary info. */
MFFILE\olfmfopen.cpp:	/* clear indicators */
MFFILE\olfmfopen.cpp: #if defined(DATADICT)
MFFILE\olfmfopen.cpp:	if (pApp->ddsetup(&mffirstfld,mffileP->mAlias,filno))	/* set up the data dictionary info. */
MFFILE\RRW\mfo.cpp://  data dictionary support.
MFMISC\mfrewind.cpp:void CRrComposite::mfdeltmp(void) /* delete mf work files */
params\qryobj.cpp://#include "..\..\dbadict\include\dbadict.h"
params\qryobj.cpp:												 m_pDataDict ) ;
params\qryobj.cpp:#if defined DATADICT_SUPPORT
params\qryobj.cpp:														 m_pDataDict ) ;
params\qryobj.cpp:														 (CDataDict *)NULL ) ;
params\qryobj.cpp:						CDataDict* pDataDict)
params\qryobj.cpp:											pDataDict ) ;
params\qryobj.cpp:	m_pDataDict = NULL ;
params\qryobj.cpp:					   CDataDict* pDataDict)
params\qryobj.cpp:	m_pDataDict = pDataDict ;
params\qryobj.cpp:					   CDataDict* pDataDict)
params\qryobj.cpp:	m_pDataDict = pDataDict ;
params\qryobj.cpp:	m_pDataDict = NULL ;
params\qryobj.cpp:#if defined DATADICT_SUPPORT
params\qryobj.cpp:	if ( m_pQueryObject->m_pDataDict )
params\qryobj.cpp:		InitDataDictControls() ;
params\qryobj.cpp:		InitDataDictControls() ;
params\qryobj.cpp:void CQueryParameter::InitDataDictControls()
params\qryobj.cpp:#if defined DATADICT_SUPPORT
params\qryobj.cpp:			if ( pParameter->m_pDataDict != NULL )
params\qryobj.cpp:				int rc = pParameter->m_pDataDict->GetAllValues(
PD\csvexp.cpp:	error			- indicates "error" data
PD\dbfexp.cpp:	Pass routine a NULL for "data" to indicate a data error
PD\htmlint.cpp://  different band lines.  We must get called here early on, indicating
PD\htmlint.cpp:		{ // put out page header indicator
PD\htmlint.cpp:						// Therfore, put out the HTML here (this indicates we are getting ready
PD\pdi.cpp:	Call this routine with the same line until returns a FALSE indicating that no fields
PD\pxint.cpp:	int nPDICode, bGotStart = FALSE;
PD\pxint.cpp:	while ( getByte( ps, &nPDICode ))
PD\pxint.cpp:		if ( nPDICode == PDI_START )
PD\pxint.cpp:				switch ( nPDICode )
PD\pxint.cpp:						if ( !wfWriteEsc( nPDICode ) ||
PD\pxint.cpp:						if ( nPDICode == PDI_ENDCENT )
PD\pxint.cpp:						if ( !wfWriteEsc( nPDICode ))
PD\pxint.cpp://							( nPDICode == PDI_CENTER ) ? PDI_ENDCENT : PDI_ENDRITE,
PD\rtfxint.cpp:		{ // put out page header indicator
PD\wksexp.cpp:	Pass routine a NULL for "data" to indicate a data error
PD-ORIG\csvexp.cpp:	error			- indicates "error" data
PD-ORIG\dbfexp.cpp:	Pass routine a NULL for "data" to indicate a data error
PD-ORIG\htmlint.cpp://  different band lines.  We must get called here early on, indicating
PD-ORIG\htmlint.cpp:		{ // put out page header indicator
PD-ORIG\htmlint.cpp:						// Therfore, put out the HTML here (this indicates we are getting ready
PD-ORIG\pdi.cpp:	Call this routine with the same line until returns a FALSE indicating that no fields
PD-ORIG\pxint.cpp:	int nPDICode, bGotStart = FALSE;
PD-ORIG\pxint.cpp:	while ( getByte( ps, &nPDICode ))
PD-ORIG\pxint.cpp:		if ( nPDICode == PDI_START )
PD-ORIG\pxint.cpp:				switch ( nPDICode )
PD-ORIG\pxint.cpp:						if ( !wfWriteEsc( nPDICode ) ||
PD-ORIG\pxint.cpp:						if ( nPDICode == PDI_ENDCENT )
PD-ORIG\pxint.cpp:						if ( !wfWriteEsc( nPDICode ))
PD-ORIG\pxint.cpp://							( nPDICode == PDI_CENTER ) ? PDI_ENDCENT : PDI_ENDRITE,
PD-ORIG\rtfxint.cpp:		{ // put out page header indicator
PD-ORIG\wksexp.cpp:	Pass routine a NULL for "data" to indicate a data error
PIC\picdata.cpp:					if ((*dot=='*') || /* indicates error */
PIC\picshape.cpp:		while (ch = *p)           // Use am indicator on shape.
PIC\picshape.cpp:		{                 //  settings, indicating 24hour format, secs display, etc.
PRINT\prec.cpp:			//  Is winBrush being used to indicate PrevWinClr is set?
REPIO\grfield.cpp:// Fixes RRW/RSW report-dictionary bug that causes a "Fatal error...
REPIO\grfield.cpp:// Part of fix to RRW bug 1771, with dquery.c, datadict.c.
REPIO\grfield.cpp://  data dictionary processing in yxHFLAGS processing.
REPIO\grfield.cpp:// Fixed a bug relating to code added for data-dictionary predefined calcs
REPIO\grfield.cpp://  a DATADICT conditional, since findfld() takes an extra argument in RSW.
REPIO\grfield.cpp://  reasons.  See datadict.c 1.0.1.2 for details.
REPIO\grfield.cpp://  has already been predefined via data-dictionary code.
REPIO\grfield.cpp:#if defined(DATADICT)
REPIO\grfield.cpp:	#include "datadict.h"	// for SecurityError, SecurityList routines
REPIO\grfield.cpp:#if defined(DATADICT)
REPIO\grfield.cpp:			// get some dict bits from copy built by datadict processing
REPIO\grfield.cpp:			fld->dFlags3 |= f3bits;		// and or in ones set up by data dict.
REPIO\grfield.cpp:#if defined(DATADICT)
REPIO\grfield.cpp:#if 0	//defined(DATADICT)
REPIO\grfield.cpp:				{	// preserve these bits from data dict processing
REPIO\grfield.cpp:									  | f3bits;		// and or in ones set up by data dict.
REPIO\grfield.cpp:#if defined(DATADICT)
REPIO\grfield.cpp:#if defined(DATADICT)
REPIO\grfield.cpp:						// get some dict bits from copy built by datadict processing
REPIO\grfield.cpp:						LastFld->dFlags3 |= f3bits;		// and or in ones set up by data dict.
REPIO\grfile.cpp://  problems.  In the process, I changed the #include datadict.h to be
REPIO\grfile.cpp://  dependent on PASSWORD_REQD, instead of DATADICT.
REPIO\grfile.cpp://  security reasons.  See datadict.c 1.0.1.2 for details.
REPIO\grfile.cpp:	//#include "datadict.h"	// for SecurityError
REPIO\grfile.cpp:			// Empty szDataSource indicates old report. This should cause
REPIO\grfile.cpp:// file will be the fully qualified file name, master indicates if called for master
REPIO\grmain.cpp://  Now init it to -1 as an indicator that we didn't see a yxFILEFLAGS record
REPIO\grmain.cpp://  Changes are also in grmisc.c, datadict.c, repio.h.
REPIO\grmain.cpp://  reasons.  Changed conditional on #include datadict.h to PASSWORD_REQD
REPIO\grmain.cpp://  instead of DATADICT, in the process.
REPIO\grmain.cpp://  security reasons.  See datadict.c 1.0.1.2 for details.
REPIO\grmain.cpp:	#include "datadict.h"	// for SecurityError, SecurityList routines, ddcalccleanup()
REPIO\grmain.cpp: #if defined(DATADICT)
REPIO\grmain.cpp:			// Remove flag indicating null-terminated record written with wstring()
REPIO\grmain.cpp:			// Remove flag indicating null-terminated record written with wstring()
REPIO\grmain.cpp:		//	that indicates whether that handler processed the current record.
REPIO\grmain.cpp:		// Once a given handler indicates that it has processed the current
REPIO\grmisc.cpp://  "unfixed" sindex values.  Changes are also in grmain.c, datadict.c, repio.h.
REPIO\grmisc.cpp://  for security reasons.  See datadict.c 1.0.1.2 for details.
REPIO\grmisc.cpp:	#include "datadict.h"
REPIO\grmisc.cpp:		arExportArchive >> objHtml.bUseColor                 ;  // NEW - indicates whether color or image is active
REPIO\rpwritex.cpp://  is necessary for predefined calcs from the data dictionary to work.
REPIO\rpwritex.cpp:			arExportArchive << objHtml.bUseColor                 ;  // NEW - indicates whether color or image is active
REPIO\RRW\xgrjoin.cpp://  reasons.  See datadict.c 1.0.1.2 for details.
REPIO\RRW\xgrjoin.cpp:#if defined(DATADICT)
REPIO\RRW\xgrjoin.cpp://#include "datadict.h"	// for SecurityError
REPIO\RSW\dbinfo.cpp:		// Remove flag indicating null-terminated record written with wstring()
REPIO\RSW\grsql.cpp://  UseDefaultDB.  Fix to WO 159630 (modified port of TMP to fix
RR\mainfrm.cpp:// Move OnUpdateKeyIndictors() out of interactive conditionals to show page
RR\mainfrm.cpp:    ON_UPDATE_COMMAND_UI(ID_INDICATOR_LINEINCH, OnUpdateKeyIndicator)
RR\mainfrm.cpp:    ON_UPDATE_COMMAND_UI(ID_INDICATOR_LINEINCH, OnUpdateKeyIndicator)
RR\mainfrm.cpp:static UINT BASED_CODE indicators[] =
RR\mainfrm.cpp:	ID_SEPARATOR,           // status line indicator
RR\mainfrm.cpp:	ID_INDICATOR_LINEINCH,	// Line: 999  Inch: (or Cent:) 99.99
RR\mainfrm.cpp:	ID_INDICATOR_CAPS,
RR\mainfrm.cpp:	ID_INDICATOR_NUM,
RR\mainfrm.cpp:		!m_wndStatusBar.SetIndicators(indicators,
RR\mainfrm.cpp:		  sizeof(indicators)/sizeof(UINT)))
RR\mainfrm.cpp:void CMainFrame::OnUpdateKeyIndicator(CCmdUI* pCmdUI)
RR\mainfrm.cpp:        case ID_INDICATOR_CAPS:
RR\mainfrm.cpp:        case ID_INDICATOR_NUM:
RR\mainfrm.cpp:        case ID_INDICATOR_SCRL:
RR\mainfrm.cpp:		case ID_INDICATOR_LINEINCH:
RR\mainfrm.cpp:                TRACE1("Warning: OnUpdateKeyIndicator - unknown indicator 0x%04X\n",
RR\mainfrm.cpp:					   theApp.driveBitFromPath(appPaths->DDFName)			|	// datadict
RR\mainfrm.cpp:					   theApp.driveBitFromPath(appPaths->DDIName));			// datadict ndx
RR\mainfrm.cpp:// settings, but OnWinIniChange() does. That contradicts the info
RR\rr.cpp:// Remove some dict. variables
RR\rr.cpp:// Added some data dictionary code.
RR\rr.cpp:	dictHead.version = 0;
RR\rr.cpp:	// ***** begin datadict.h
RR\rr.cpp:	// ***** end datadict.h
RR\rr.cpp:work, since all other indices result in the corresponding icon being used (e.g. 0 uses app, 2
RR\rrcompos.cpp://   (modified port of TMP for WO 156383)
RR\rrcompos.cpp:#if defined(DATADICT)
RR\rrdoc.cpp:// In OnSaveDocument, set flag indicating whether we're resaving or
RR\rrdoc.cpp:   Snaking = 0;      // indicates whether or not we are doing snaked cols
RR\rrdoc.cpp:   HOArg = 0;  // flag indicating asynchronous call to runtime EXE
RR\rrdoc.cpp:#if defined(DATADICT)
RR\rrdoc.cpp:   bMainPalSet = FALSE;  // Indicates that a palette was installed for the MainDC.
RR\rrdoc.cpp:// generates an all-band dbf report in "tmpResultSet.dbf"
RR\rrdoc.cpp:   BOOL tmpPrinting = Printing;
RR\rrdoc.cpp:   TCHAR tmpExportType = m_pExport->ExportType;
RR\rrdoc.cpp:   char tempDir[WINPATHLEN+1], tmpCSFilename[WINPATHLEN+1];
RR\rrdoc.cpp:   GetTempFileName(tempDir, "RSB", 0, tmpCSFilename) ;
RR\rrdoc.cpp:   strcpy(Paths->ExpDbfPath , tmpCSFilename);
RR\rrdoc.cpp:   Printing = tmpPrinting;
RR\rrdoc.cpp:   m_pExport->ExportType = tmpExportType;
RR\rrdoc.cpp:   strcpy(Paths->ExpDbfPath, tmpCSFilename);
RR\rrdoc.cpp:      sprintf(cmdline, "%s %s", "rrbrowse", tmpCSFilename);
RR\rrview.cpp:// Consider user wants no part of dictionary
RR\rrview.cpp:#if defined(DATADICT)
RR\rrview.cpp:#include "datadict.h"	// for SecurityLevel, DDRecordSecurity
RR\rrview.cpp:	ON_UPDATE_COMMAND_UI ( IDM_POPUP_FIELD_DICTIONARY, OnUpdatePropDictionary   )
RR\rrview.cpp:	ON_COMMAND ( IDM_POPUP_FIELD_DICTIONARY, OnPopupFieldDictionary     )
RR\rrview.cpp:void CRrView::OnUpdatePropDictionary(CCmdUI* pCmdUI)
RR\rrview.cpp:			m_pDoc->Defs.Dictionary &&
RR\rrview.cpp:void CRrView::OnPopupFieldDictionary()
RR\rulervw.cpp:	// call DelayShow to clear any contradictory DelayShow
RRATL\RRControl.cpp:	char m_tmpPdiFileName[2048];
RRATL\RRControl.cpp:	sprintf(m_tmpPdiFileName,"%s\\%d.pdi",tempdir, GetTickCount());
RRATL\RRControl.cpp:	return m_tmpPdiFileName;
rrocx\report.cpp:	//  that we use the value of printer to indicate - Use saved printer, prompt user or
rrocx\vbutil.cpp://  page we have indicated here is displayed.
rrrpt32\rdinit.cpp:	YYFILETAB *tmpRepFile;
rrrpt32\rdinit.cpp:		if (openReportLibrary(szLibName, &tmpRepFile)) // make sure we can open it before dialog
rrrpt32\rdinit.cpp:				if (yzn = m_pDoc->yzread1name(tmpRepFile,rep))	// try to find requested report in specified lib
rrrpt32\rdinit.cpp:					repFileTable = tmpRepFile;		// remember ftab address
rrrpt32\rdinit.cpp:					m_pDoc->yyclose(tmpRepFile);
rrrpt32\rdinit.cpp:				m_pDoc->yyclose(tmpRepFile);	// close it right back up
rrrpt32\rdreport.cpp:			// Remove flag indicating null-terminated record written with wstring()
rrrpt32\rdreport.cpp:	LPSTR lpszPtr = NULL, lpszTmp;
rrrpt32\rdreport.cpp:			for (lpszTmp = lpszPtr; size && *lpszTmp != cQuote; lpszTmp++, size--);
rrrpt32\rdreport.cpp:			copyLen = lpszTmp - lpszPtr;
rrrpt32\rdreport.cpp:			lpszPtr = lpszTmp;
rrrpt32\rdreport.cpp:						// record indicating a converted DOS report
rrrpt32\rdrepval.cpp:// Fixes bug where sort field direction indicator was backwards.  See also
rrrpt32\rdtable.cpp://  suitable for use with report dict - as well as full name.
rrrpt32\rdtable.cpp:#include "datadict.h"	// for dbf reading defines, structures
rrrpt32\rdtable.cpp:	DBHEADER dictHead;					/* database file header structure */
rrrpt32\rdtable.cpp:		/* open dictionary file */
rrrpt32\rdtable.cpp:	if (FREAD(dbhandle,(LPSTR)&dictHead,sizeof(DBHEADER)) < 0)
rrrpt32\rdtable.cpp:	if ((dictHead.inctrans) || (dictHead.encrypt))
rrrpt32\rdtable.cpp:	for (i=FSTFIELD;  (i < (long)(dictHead.headlen) - 1); i+=NXTFIELD)
rrrpt32\rdtable.cpp:LPSTR sql_prep_tablename_for_dict (LPSTR lpszNameIn, LPSTR lpszNameOut)
rrrpt32\rdtable.cpp:		pComposite->sql_prep_tablename_for_dict (qtable, table);	// make short version (args are 'in', 'out')
rrrpt32\rdtable.cpp:		pComposite->sql_prep_tablename_for_dict (table, table);
rrrpt32\rdwrite.cpp:	char szTmp [_MAX_PATH];
rrrpt32\rdwrite.cpp:	GetTempFileName (szPath, m_Util.getFString(IDS_RRUN, 0), 0, szTmp);	// "RRUN"
rrrpt32\rdwrite.cpp:	hTempFile = _lcreat (szTmp, 0);
rrrpt32\rdwrite.cpp:		if (!WritePrivateProfileString (m_Util.getFString(IDS_RANDR, 0), name, value, szTmp))	// "R&R Runtime"
rrrpt32\rdwrite.cpp:			wsprintf (m_Util.ErrorBuf, m_Util.getFString(IDS_WRITE_ERR,2), name, szTmp); //"Cannot write %s to %s"
rrrpt32\rdwrite.cpp:	if (!(tempFile = fopen (szTmp, "r")))
rrrpt32\rdwrite.cpp:		wsprintf (m_Util.ErrorBuf, m_Util.getFString(IDS_OPEN_ERR,2), szTmp); //"Cannot open file: %s for writing"
rrsqlwiz\convert.cpp:	CVTFIELD *FldTmp;
rrsqlwiz\convert.cpp:		FldTmp = FldPtr->NxtFld;
rrsqlwiz\convert.cpp:		FldPtr = FldTmp;
rrsqlwiz\convert.cpp://	nType is warning/error indication
rrsqlwiz\convwiz.cpp:	HideProgress();	// hide progress indicator
rrsqlwiz\convwiz.cpp:// Set up progress indicator
rrsqlwiz\convwiz.cpp:// Hide the indicator when done
rrsqlwiz\dschange.cpp:	//  the lousy ODBC drivers do not return consistent indication
rrsqlwiz\fielddlg.cpp:// Catch all the ridiculous help messages
rrsqlwiz\fielddlg.cpp:// Catch all the ridiculous help messages
rrsqlwiz\ovrwtdlg.cpp:// Catch all the ridiculous help messages
rrsqlwiz\ovrwtdlg.cpp:// Catch all the ridiculous help messages
rrsqlwiz\pass1.cpp:	LPSTR pTmp;
rrsqlwiz\pass1.cpp:	if ( pTmp = strrchr( filename, '\\' ))
rrsqlwiz\pass1.cpp:		lstrcpy( szTemp, pTmp + 1 );
rrsqlwiz\pass1.cpp:	if ( pTmp = strrchr( szTemp, '.' ))
rrsqlwiz\pass1.cpp:		*pTmp = '\0';
rrsqlwiz\report.cpp:			// Remove flag indicating null-terminated record written with wstring()
rrsqlwiz\statdlg.cpp:// Catch all the ridiculous help messages
rrsqlwiz\statdlg.cpp:// Catch all the ridiculous help messages
rrsqlwiz\tabledlg.cpp:// Catch all the ridiculous help messages
rrsqlwiz\tabledlg.cpp:// Catch all the ridiculous help messages
rrsqlwiz\wrrw_rsw.cpp:				// change alias indicator '->' to '.'
RRWCNVRT\convert.cpp:	RRWCNVRTIcon = LoadIcon("conico") ;
RRWCNVRT\convert.cpp:	char tmplt;
RRWCNVRT\convert.cpp:					tmplt = source_name[strlen(source_name)-2];
RRWCNVRT\convert.cpp:					if (toupper(tmplt) == 'T')
RRWCNVRT\convert.cpp:						dest_name[strlen(dest_name)-2] = tmplt;
RRWCNVRT\convert.cpp:	CVTFIELD *FldTmp;
RRWCNVRT\convert.cpp:		FldTmp = FldPtr->NxtFld;
RRWCNVRT\convert.cpp:		FldPtr = FldTmp;
RRWCNVRT\convert.cpp:	CVTFILE *FileTmp;
RRWCNVRT\convert.cpp:		FileTmp = FilePtr->NxtFile;
RRWCNVRT\convert.cpp:		FilePtr = FileTmp;
RRWCNVRT\mainfrm.cpp:static UINT BASED_CODE indicators[] =
RRWCNVRT\mainfrm.cpp:	ID_SEPARATOR,           // status line indicator
RRWCNVRT\mainfrm.cpp:	ID_INDICATOR_CAPS,
RRWCNVRT\mainfrm.cpp:	ID_INDICATOR_NUM,
RRWCNVRT\mainfrm.cpp:	ID_INDICATOR_SCRL,
RRWCNVRT\mainfrm.cpp:		!m_wndStatusBar.SetIndicators(indicators,
RRWCNVRT\mainfrm.cpp:		  sizeof(indicators)/sizeof(UINT)))
RRWCNVRT\report.cpp:			// Remove flag indicating null-terminated record written with wstring()
RRWCNVRT\report.cpp:			// Remove flag indicating null-terminated record written with wstring()
RRWCNVRT\rp2_rp6.cpp:// To create PTF for TMP133993.
RRWCNVRT\rp2_rp6.cpp:				// change alias indicator '->' to '.'
RRWCNVRT\rp4_rp6.cpp:				// change alias indicator '->' to '.'
RRWCNVRT\rp5_rp6.cpp:			// change alias indicator '->' to '.' --------------------------
RRWCNVRT\rp6_rp5.cpp:			// change alias indicator '.' to '->' --------------------------
RRWCNVRT\rrw_rsw.cpp:			// change alias indicator '->' to '.' --------------------------
RRWCNVRT\RSW_RRW.CPP:			// change alias indicator '.' to '->' --------------------------
RUNTIME\rrruntim.cpp:	bReadingRuninDBF = 0;			// indicates that we'd like bigger buffers to
RUNTIME\rrun.cpp:// Remove some data dictionary crap
RUNTIME\rrun.cpp:// runtime sometimes runs off temp files not defined in dict.
RUNTIME\rrun.cpp:	dictHead.version = 0;
RUNTIME\rrun.cpp:	// ***** begin datadict.h
RUNTIME\rrun.cpp:	DDdoNothing = TRUE;		// Abra doesn't want security in runtime because they sometimes report on temp files which aren't in dict
RUNTIME\rrun.cpp:	// ***** end datadict.h
RUNTIME\runtime.cpp:// Added support for /HO argument indicating asynchronous call from DLL.
RUNTIME\runtime.cpp:	char tmp[MAX_MESSAGE + 10];
RUNTIME\runtime.cpp:			sprintf(tmp,"%s=%c\r\n",T0RunOF,RpErrType); /* RO_ECODE */
RUNTIME\runtime.cpp:			ROFile.Write( tmp, strlen(tmp) );
RUNTIME\runtime.cpp:			sprintf(tmp,"%s=%s\r\n",T1RunOF,emsg);          /* RO_EMSG */
RUNTIME\runtime.cpp:			ROFile.Write( tmp, strlen(tmp) );
RUNTIME\runtime.cpp:				sprintf(tmp,"%s=%c\r\n",T0RunOF,RpErrType); /* RO_ECODE */
RUNTIME\runtime.cpp:				ROFile.Write( tmp, strlen(tmp) );
RUNTIME\runtime.cpp:				sprintf(tmp,"%s=%s\r\n",T1RunOF,emsg);          /* RO_EMSG */
RUNTIME\runtime.cpp:				ROFile.Write( tmp, strlen(tmp) );
RUNTIME\runtime.cpp:				sprintf(tmp,"%s=N\r\n",T0RunOF);        /* RO_ECODE */
RUNTIME\runtime.cpp:				ROFile.Write( tmp, strlen(tmp) );
RUNTIME\runtime.cpp:				sprintf(tmp,"%s=\r\n",T1RunOF);     /* RO_EMSG blank */
RUNTIME\runtime.cpp:				ROFile.Write( tmp, strlen(tmp) );
RUNTIME\runtime.cpp:			sprintf(tmp,"%s=N\r\n",T0RunOF);        /* RO_ECODE */
RUNTIME\runtime.cpp:			ROFile.Write( tmp, strlen(tmp) );
RUNTIME\runtime.cpp:			sprintf(tmp,"%s=\r\n",T1RunOF);     /* RO_EMSG blank */
RUNTIME\runtime.cpp:			ROFile.Write( tmp, strlen(tmp) );
RUNTIME\runtime.cpp:		sprintf(tmp,"%s=%d\r\n",T2RunOF,RpJobs);            /* RO_REPORTS */
RUNTIME\runtime.cpp:		ROFile.Write( tmp, strlen(tmp) );
RUNTIME\runtime.cpp:		sprintf(tmp,"%s=%d\r\n",T3RunOF,pages);         /* RO_PAGES */
RUNTIME\runtime.cpp:		ROFile.Write( tmp, strlen(tmp) );
RUNTIME\runtime.cpp:			sprintf(tmp,"%s=\r\n",T4RunOF);         /* RO_RIID blank */
RUNTIME\runtime.cpp:			sprintf(tmp,"%s=%d\r\n",T4RunOF,RpJobRec);  /* RO_RIID number */
RUNTIME\runtime.cpp:		ROFile.Write( tmp, strlen(tmp) );
RUNTIME\runtime.cpp:			sprintf(tmp,"%s=%d\r\n",T2RunOF,RpJobs);            /* RO_REPORTS */
RUNTIME\runtime.cpp:			ROFile.Write( tmp, strlen(tmp) );
RUNTIME\runtime.cpp:			sprintf(tmp,"%s=%d\r\n",T3RunOF,pages);         /* RO_PAGES */
RUNTIME\runtime.cpp:			ROFile.Write( tmp, strlen(tmp) );
RUNTIME\runtime.cpp:			sprintf(tmp,"%s=%d\r\n",T4RunOF,RpJobRec);  /* RO_RIID number */
RUNTIME\runtime.cpp:			ROFile.Write( tmp, strlen(tmp) );
RUNTIME\wnextjob.cpp:// Fix ascii-runin RI_SERVER.  It was being cleared by the RI_DICTDIR code.
RUNTIME\wnextjob.cpp:	int		gotddir = FALSE;		// read an RI_DATADIR or RI_DICTDIR field
RUNTIME\wnextjob.cpp:			// "Invalid printer indicator: %c"
RUNTIME\wnextjob.cpp:				return m_pDoc->zacknum(getString(IDS_1007,0),(LONG)RpPrnNo); // "Invalid printer indicator: %c"
RUNTIME\wnextjob.cpp:	swrstr(WxWDataSource,JF_DATASOURCE);		// RI_SERVER - before dictdir
RUNTIME\wnextjob.cpp:	int		gotddir = FALSE;				// read an RI_DATADIR or RI_DICTDIR field
RUNTIME\wnextjob.cpp:				// "Invalid printer indicator: %c"
RUNTIME\wnextjob.cpp:					// "Invalid printer indicator: %c"
RUNTIME\wrtmain.cpp:#if defined(DATADICT) && defined(PASSWORD_REQD)
RUNTIME\wrtmain.cpp:#if defined(DATADICT) && defined(PASSWORD_REQD)
RUNTIME\wrtmain.cpp:#if defined(DATADICT) && defined(PASSWORD_REQD)
RUNTIME\wrtmain.cpp:#if defined(DATADICT) && defined(PASSWORD_REQD)
SETUP\postinst\rdpostin.cpp:// and a second argument of $(INSTTYPE) to indicate when uninstalling
SETUP\postinst\rdpostin.cpp:	if ((!entryExists( "Data Dictionary", "DataDict", NULL)) &&
SETUP\postinst\rdpostin.cpp:		 (!entryExists( "Data Dictionary", "DataDictIndex", NULL)))
SETUP\postinst\rdpostin.cpp:		addSubdir( pathbuf, "Sample\\rrdict.dbf" );
SETUP\postinst\rdpostin.cpp:		WritePrivateProfileString( "Data Dictionary", "DataDict", pathbuf, rswIni );
SETUP\postinst\rdpostin.cpp:		addSubdir( pathbuf, "Sample\\rrdict.ndx" );
SETUP\postinst\rdpostin.cpp:		WritePrivateProfileString( "Data Dictionary", "DataDictIndex", pathbuf, rswIni );
SETUP\postinst\rvpostin.cpp:// and a second argument of $(INSTTYPE) to indicate when uninstalling
SORT\sortmerg.cpp:	{	char *tmp = line[0];				// no, remember funny one
SORT\sortmerg.cpp:		line[i] = tmp;						// fill in funny one
SORT\sortutil.cpp:		ereal = eflgs & 0x80;		// high-order bit is reality indicator
SPEC\specfld1.cpp:	/* no indication of leading blanks/zeros; decimal places; 2/4-digit yrs */
SPEC\specfld1.cpp:		{                 //  settings, indicating 24hour format, secs display, etc.
WBAND\bandview.cpp:	// fill bands with colors indicating their type
WBAND\bandview.cpp:		{ // indicate logical/scan lines
WBAND\dljust.cpp:			// lParam indicates band line justify or 2D alignment
WDISPLAY\splashwn.cpp:	imageDC.SelectObject(pSavedBitmap);	// restore original bitmpa, so we can delete ours
WDISPLAY\statbar.cpp:static UINT BASED_CODE indicators[] =
WDISPLAY\statbar.cpp:	ID_SEPARATOR,           // status line indicator
WDISPLAY\statbar.cpp:	ID_INDICATOR_LINEINCH,	// Line: 999  Inch: (or Cent:) 99.99
WDISPLAY\statbar.cpp:	ID_INDICATOR_CAPS,
WDISPLAY\statbar.cpp:	ID_INDICATOR_NUM,
WDISPLAY\statbar.cpp:#if defined(DATADICT)
WDISPLAY\statbar.cpp:#if defined(DATADICT)
WDISPLAY\statbar.cpp:#if defined(DATADICT)
WDISPLAY\statbar.cpp:									lstrcpy(m_pDoc->m_pComposite->CfEvalStack, getString(IDS_0675, 0));	// yes, indicator present
WDISPLAY\statbar.cpp:									*m_pDoc->m_pComposite->CfEvalStack = '\0';             // no, indicator absent
WDISPLAY\statbar.cpp:#if defined(DATADICT)
WDISPLAY\statbar.cpp: #if defined(DATADICT)
WDISPLAY\statbar.cpp: #if defined(DATADICT)
WDISPLAY\statbar.cpp: #if defined(DATADICT)
WDISPLAY\statbar.cpp: #if defined(DATADICT)
WDISPLAY\statbar.cpp:		if (!SetIndicators(helpbar,sizeof(helpbar)/sizeof(UINT)))
WDISPLAY\statbar.cpp:		if (!SetIndicators(indicators,  sizeof(indicators)/sizeof(UINT)))
WLAYOUT\wcaret.cpp:// Call statusInfo() with flag to indicate no redraw needed.
WLAYOUT\wcaret.cpp:void CRrView::rulerCaret(int x, int width)	// indicate current location in ruler
WLAYOUT\wfont.cpp:// Check for box height of 0xFFFF.  It's now saved in the report to indicate
WLAYOUT\wfont.cpp:// Call sizeBandsFlds() twice in sizeFlds().  Ridiculous.
WLAYOUT\wfont.cpp:			hite_chg = TRUE;				  // line hite change indication
WLAYOUT\wprop.cpp:		appendMenuItem( &propMenu, IDM_POPUP_FIELD_DICTIONARY, IDM_FIELD_DICTIONARY );
WMAIN\cmdline.cpp:#if defined(DATADICT)
WMAIN\cmdline.cpp:#include "datadict.h"	// for SecurityLevel, DDRecordSecurity
WMAIN\cmdline.cpp:#if defined(DATADICT) && defined(PASSWORD_REQD)
WMAIN\explmgr.cpp:	can include a trailing point character (.) to indicate that the module 
WMAIN\rrinit.cpp:// Leave the data dict. entries alone, after all
WMAIN\rrinit.cpp:// to indicate when in template read mode.
WMAIN\rrinit.cpp:#if defined(DATADICT)
WMAIN\rrinit.cpp:#include "datadict.h"	// for SecurityLevel, DDRecordSecurity
WMAIN\rrinit.cpp:	// Doc for LoadCursor/LoadIcon says we should do this.
WMAIN\rrinit.cpp:#if defined(DATADICT)
WMAIN\rrinit.cpp:	// remove any dictionary entries in ini file
WMAIN\rrinit.cpp:		convertDict() ;
WMAIN\rrinit.cpp:		WritePrivateProfileString(WxDictKey, WxDataDict, NULL, theApp.m_elmFileManager.GetRRInitFile());
WMAIN\rrinit.cpp:		sprintf(skey, ";%s", WxDataDict) ;
WMAIN\rrinit.cpp:		WritePrivateProfileString(WxDictKey, skey, theApp.Paths->DDFName, theApp.m_elmFileManager.GetRRInitFile());
WMAIN\rrinit.cpp:		WritePrivateProfileString(WxDictKey, WxDataDictIx, NULL, theApp.m_elmFileManager.GetRRInitFile());
WMAIN\rrinit.cpp:		sprintf(skey, ";%s", WxDataDictIx) ;
WMAIN\rrinit.cpp:		WritePrivateProfileString(WxDictKey, skey, theApp.Paths->DDIName, theApp.m_elmFileManager.GetRRInitFile());
WMAIN\rrinit.cpp:	// always use default dictionary in /rl
WMAIN\rrinit.cpp:	sprintf(theApp.Paths->DDFName, "%s%s", theApp.Paths->LibrarianDataPath, "dictfld.dbf") ;
WMAIN\rrinit.cpp:	sprintf(theApp.Paths->DDIName, "%s%s", theApp.Paths->LibrarianDataPath, "dictfld.cdx") ;
WMAIN\rrinit.cpp:#if defined(DATADICT) && defined(PASSWORD_REQD)
WMAIN\rrinit.cpp:#if defined(DATADICT)
WMAIN\rrinit.cpp:// if you find a heathen dictionary, convert the bastard
WMAIN\rrinit.cpp:void CRrApp::convertDict()
WMAIN\rrinit.cpp:	GetTempFileName(tempDir, "dict", 0, path) ;
WMAIN\version.cpp:// succeeds;  else it fails, and a message is produced indicating the dll
WMAIN\version.cpp:		LPSTR lpszTmpMessage = pDoc->globalAlloc (GMEM_ZEROINIT, 1024);
WMAIN\version.cpp:		wsprintf (lpszTmpMessage, "Error Loading %s. Required Version: %d;  Actual version: %d",
WMAIN\version.cpp:		::MessageBox (AfxGetMainWnd()->GetSafeHwnd(), lpszTmpMessage, "Error Loading DLL", MB_OK);
WMAIN\version.cpp:		pDoc->globalFree (lpszTmpMessage);
WMAIN\winit.cpp:// Get a possible Dictionary entry from ini file
WMAIN\winit.cpp://  on INTERACTIVE, so report dictionary info can appear in interactive
WMAIN\winit.cpp:// Fixed maximum string lengths in several DATADICT-related
WMAIN\winit.cpp:// Added GetPrivateProfileString() calls for 3 new data dictionary fields.
WMAIN\winit.cpp://  Added conditional support for data dictionary and custom title screen.
WMAIN\winit.cpp:// Added support for Data Dictionary and custom-title-screen .ini settings.
WMAIN\winit.cpp:#include "mfmisc.h"     // for mfreset(), mfdeltmp()
WMAIN\winit.cpp:#if defined(DATADICT)
WMAIN\winit.cpp:#include "datadict.h"	// for DDFName[], DDIName[]
WMAIN\winit.cpp:	GetPrivateProfileString("Runtime","DICTPATH",
WMAIN\winit.cpp:	GetPrivateProfileString("Runtime","DICTID",
WMAIN\winit.cpp:	sprintf(theApp.Paths->DDFName, "%s%s", theApp.Paths->LibrarianDataPath, "dictfld.dbf") ;
WMAIN\winit.cpp:	sprintf(theApp.Paths->DDIName, "%s%s", theApp.Paths->LibrarianDataPath, "dictfld.cdx") ;
WMAIN\winit.cpp:#if defined(DATADICT)
WMAIN\winit.cpp:	// Data dictionary filename & index
WMAIN\winit.cpp://	GetPrivateProfileString( WxDictKey, WxDataDict,   "", theApp.Paths->DDFName,WINPATHLEN+1, theApp.m_elmFileManager.GetRRInitFile());
WMAIN\winit.cpp://	GetPrivateProfileString( WxDictKey, WxDataDictIx, "", theApp.Paths->DDIName,WINPATHLEN+1, theApp.m_elmFileManager.GetRRInitFile());
WMAIN\winit.cpp:	Defs.Dictionary = GetPrivateProfileInt(WxDefKey, "Dictionary",1, theApp.m_elmFileManager.GetRRInitFile());
WMAIN\winit.cpp:	// Data dictionary "soft" field names
WMAIN\winit.cpp:	GetPrivateProfileString( WxDictKey, WxTable_Name, WxTable_Name, theApp.DDTableName,      MAXDNAME+1, theApp.m_elmFileManager.GetRRInitFile());
WMAIN\winit.cpp:	GetPrivateProfileString( WxDictKey, WxField_Name, WxField_Name, theApp.DDFieldName,      MAXDNAME+1, theApp.m_elmFileManager.GetRRInitFile());
WMAIN\winit.cpp:	GetPrivateProfileString( WxDictKey, WxSecurity,   WxSecurity,   theApp.DDSecurityName,   MAXDNAME+1, theApp.m_elmFileManager.GetRRInitFile());
WMAIN\winit.cpp:	GetPrivateProfileString( WxDictKey, WxComment,    WxComment,    theApp.DDCommentName,    MAXDNAME+1, theApp.m_elmFileManager.GetRRInitFile());
WMAIN\winit.cpp:	GetPrivateProfileString( WxDictKey, WxExtended,   WxExtended,   theApp.DDExtendedName,   MAXDNAME+1, theApp.m_elmFileManager.GetRRInitFile());
WMAIN\winit.cpp:	GetPrivateProfileString( WxDictKey, WxFormula409, WxFormula409, theApp.DDFormulaName,    MAXDNAME+1, theApp.m_elmFileManager.GetRRInitFile());
WMAIN\winit.cpp:	GetPrivateProfileString( WxDictKey, WxFieldList,  WxFieldList,  theApp.DDFieldListName,  MAXDNAME+1, theApp.m_elmFileManager.GetRRInitFile());
WMAIN\winit.cpp:	GetPrivateProfileString( WxDictKey, WxFilterList, WxFilterList, theApp.DDFilterListName, MAXDNAME+1, theApp.m_elmFileManager.GetRRInitFile());
WMAIN\winit.cpp:	GetPrivateProfileString( WxDictKey, WxInstantRep, WxInstantRep, theApp.DDInstantRepName, MAXDNAME+1, theApp.m_elmFileManager.GetRRInitFile());
WMAIN\winit.cpp:#if defined(DATADICT) && defined(PASSWORD_REQD)
WMAIN\winit.cpp:	m_pComposite->mfdeltmp();
WPRINTUI\wexport.cpp:	m_pDoc->RepType = REPNORM;		// "normal" report indicated now because used in printCommon in RSW
WPRINTUI\wexport.cpp:	m_pDoc->RepType = REPNORM;		// "normal" report indicated now because used in printCommon in RSW
WPRINTUI\wprint.cpp:		// The following is ridiculous code that checks for the lousy
WPRINTUI\wtxtexp.cpp:// Change initPrinter arg to TRUE (indicates we're not previewing).
WREPORT\mru.cpp:	// Return an indication that we found and removed the entries
WREPORT\rpinit.cpp:	m_pComposite->mfdeltmp();
WREPORT\RSW\sconnect.cpp:// dicsonnect DS if can't use it in connectAndChooseTables
WREPORT\RSW\sconnect.cpp:			 // put up Tables dialog - 1 indicates choosing orig. master table
WREPORT\winst.cpp:// Added code, conditional on DATADICT, to exclude certain fields from
WREPORT\winst.cpp://  instant reports, based on a new logical field in the data dictionary.
WREPORT\winst.cpp:// Added code conditional on DATADICT from Abra branch that avoids zapping
WREPORT\winst.cpp://  used to do.  Also changed mfcalc to accept new arg, datadict.c to
WREPORT\winst.cpp:#if defined(DATADICT)
WREPORT\winst.cpp:#if defined(DATADICT)
WREPORT\wiz.cpp:// dictionary calcs were not set right because database info was used.
WREPORT\wiz.cpp:// Call sql_prep_tablename_for_dict (yes, that's right) for tweaking table name
WREPORT\wiz.cpp:		m_pComposite->sql_prep_tablename_for_dict(Paths->CIPName, szMasterTable));
WREPORT\wreport.cpp:// don't reread eval-once calcs from data dict.
WREPORT\wreport.cpp:#include "datadict.h"	// for DDChangeFile
WREPORT\wreport.cpp:/* "template" argument indicates whether or not called to select a database as a result of a 
WREPORT\wreport.cpp:		// don't reread eval-once calcs from data dict
WREPORT\wreport.cpp:			repstat = RPMFCERR;		// indicate failure of MFC OnOpenDocument
WUTIL\custcfd.cpp:	CWnd* pWnd = GetDlgItem(IDMASTEROPENDICT) ;
WUTIL\custcfd.cpp:void CRRFileDialog::OnIDMasterOpenDict() 
WUTIL\custcfd.cpp:	ON_BN_CLICKED(IDMASTEROPENDICT, OnIDMasterOpenDict)
WUTIL\custcfd.cpp:		// and want zero to indicate no "not avail" ds
WUTIL\custcfd.cpp:			// and want zero to indicate no "not avail" ds
WUTIL\fldlist.cpp:// Modify filter for Add to Dictionary button
WUTIL\fldlist.cpp:#if defined(DATADICT)
WUTIL\fldlist.cpp:					// Set "extra data" to -1L to indicate an "alias" entry
WUTIL\fldlist.cpp:#if defined(DATADICT)
WUTIL\labels.cpp:	return(FALSE);		// no dice
WUTIL\wdialog.cpp://  data-dictionary descriptions, or both.  This code works by using the
WUTIL\wdialog.cpp:// Added code from Abra branch, conditonal on DATADICT, that excludes
WUTIL\wdialog.cpp:	::DrawIcon(hDC, rc.left, rc.top, LoadIcon((HINSTANCE)NULL, icon));
WUTIL\wfile.cpp:   strcpy( dlgname, "DMasterOpenDict");
WUTIL\wfile.cpp:      "stc32" is a special control id that indicates where to put the standard controls.
XBASE\DBF.CPP:      TempDbfName += "TMPXBASE.DBF";
XBASE\DBF.CPP:     TempDbfName = "TMPXBASE.DBF";
XBASE\DBF.CPP:   if(( rc = RebuildAllIndices()) != XB_NO_ERROR ) 
XBASE\DBF.CPP:xbShort xbDbf::RebuildAllIndices()
XBASE\DBF.CPP:      TempDbfName += "TMPXBASE.DBF";
XBASE\DBF.CPP:		 TempDbfName = "TMPXBASE.DBF";
XBASE\DBF.CPP:   if(( rc = RebuildAllIndices()) != XB_NO_ERROR )
XBASE\dfselect.cpp:		hdlCkbxClz = *GetDlgItem(DICLOSEDLG);
XBASE\XBSTRING.CPP:	xbString tmp(s1.getData());
XBASE\XBSTRING.CPP:	tmp += s2;
XBASE\XBSTRING.CPP:	return tmp;
XBASE\XBSTRING.CPP:	xbString tmp(s1.getData());
XBASE\XBSTRING.CPP:	tmp += s2;
XBASE\XBSTRING.CPP:	return tmp;
XBASE\XBSTRING.CPP:	xbString tmp(s1);
XBASE\XBSTRING.CPP:	tmp += s2;
XBASE\XBSTRING.CPP:	return tmp;
XBASE\XBSTRING.CPP:	xbString tmp(s1.getData());
XBASE\XBSTRING.CPP:	tmp += c2;
XBASE\XBSTRING.CPP:	return tmp;
XBASE\XBSTRING.CPP:	xbString tmp(c1);
XBASE\XBSTRING.CPP:	tmp += s2;
XBASE\XBSTRING.CPP:	return tmp;
XBASE\XDATE.CPP:  Months[11] = "Diciembre\0";
