DFORMAT\dstyle.cpp:			CF_INITTOLOGFONTSTRUCT | CF_LIMITSIZE | CF_PRINTERFONTS | CF_SHOWHELP;
DFORMAT\dstyle.cpp:		cf.nFontType |= PRINTER_FONTTYPE;
FILTER\pksx.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
FILTER\sxmisc.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
CFCOMP\token.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
CFCOMP\explt.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
rrocx\property.cpp:BSTR CRrocxCtrl::GetPrinter()
rrocx\property.cpp:	return m_strPrinter.AllocSysString() ;
rrocx\property.cpp:void CRrocxCtrl::SetPrinter(LPCTSTR lpszNewValue)
rrocx\property.cpp:	m_strPrinter = lpszNewValue ;
rrocx\property.cpp:short CRrocxCtrl::GetCopiesToPrinter()
rrocx\property.cpp:	return m_iCopiesToPrinter ;
rrocx\property.cpp:void CRrocxCtrl::SetCopiesToPrinter(short nNewValue)
rrocx\property.cpp:	m_iCopiesToPrinter=nNewValue ;
rrocx\report.cpp:	// Copies to Printer
rrocx\report.cpp:	if ( !setCopies(nReportHandle, (long)m_iCopiesToPrinter) )
rrocx\report.cpp:	// Printer
rrocx\report.cpp:	if ( !(m_strPrinter.IsEmpty()) )
rrocx\report.cpp:		strcpy ( szTemp, m_strPrinter ) ;
rrocx\report.cpp:		if ( !setPrinter(nReportHandle, szTemp) )
rrocx\report.cpp:	// Copies To Printer
rrocx\report.cpp:	SetCopiesToPrinter ( iTemp ) ;
rrocx\report.cpp:	// Printer
rrocx\report.cpp:	// We do not want to set Printer to the value that is in the report.  The reason being
rrocx\report.cpp:	//  that we use the value of printer to indicate - Use saved printer, prompt user or
rrocx\report.cpp:	//  override printer.  We want the value to be Use saved printer initiaily. So set the
rrocx\report.cpp:	//  Printer to "".  If we want to get the value, uncomment the next two lines
rrocx\report.cpp:	// - getPrinter ( nReportHandle, strTemp.GetBuffer(WINPATHLEN ), WINPATHLEN ) ;
rrocx\report.cpp:	SetPrinter ( strTemp ) ;
rrocx\vbutil.cpp:#include "printppg.h"	// CPrinterOptionsPropPage
rrocx\vbutil.cpp:			Name = _T("1 - Printer") ;
rrocx\vbutil.cpp:			Name = _T("2 - Printer"           ) ;
rrocx\vbutil.cpp:		case 1: strValue = _T("1 - Printer") ;
rrocx\vbutil.cpp:		case 2:  strValue = _T("2 - Printer"           ) ;
rrocx\vbutil.cpp:		case dispidPrinter:
rrocx\vbutil.cpp:			// editing of the Printer/Port
rrocx\vbutil.cpp:			*lpclsid = CPrinterOptionsPropPage::guid ;
rrocx\printppg.cpp:// This is the printer property page module.
rrocx\printppg.cpp:// Added code so that selecting printer/overide/prompt radio button in the print
rrocx\printppg.cpp:// Made sure printer name is filled in if user selects to override the saved
rrocx\printppg.cpp:// printer.
rrocx\printppg.cpp:// Made changes for printer and port.
rrocx\printppg.cpp:// Adding printer support.
rrocx\printppg.cpp:#include "printppg.h"  // CPrinterOptionsPropPage
rrocx\printppg.cpp:// CPrinterOptionsPropPage dialog
rrocx\printppg.cpp:IMPLEMENT_DYNCREATE(CPrinterOptionsPropPage, COlePropertyPage)
rrocx\printppg.cpp:BEGIN_MESSAGE_MAP(CPrinterOptionsPropPage, COlePropertyPage)
rrocx\printppg.cpp:	//{{AFX_MSG_MAP(CPrinterOptionsPropPage)
rrocx\printppg.cpp:	ON_BN_CLICKED(IDC_BROWSE_PRINTER, OnBrowsePrinter)
rrocx\printppg.cpp:IMPLEMENT_OLECREATE_EX(CPrinterOptionsPropPage, "CPrinterOptionsPropPage0.CPrinterOptionsPropPage", 0x5baa9423, 0x143d, 0x11cf, 0xbd, 0x27, 0x10, 0x0, 0x5a, 0xe6, 0xaf, 0xfa)
rrocx\printppg.cpp:IMPLEMENT_OLECREATE_EX(CPrinterOptionsPropPage, "CPrinterOptionsPropPage0.CPrinterOptionsPropPage", 0x5bba9423, 0x143d, 0x11cf, 0xbd, 0x27, 0x10, 0x0, 0x5a, 0xe6, 0xaf, 0xfa)
rrocx\printppg.cpp:// CPrinterOptionsPropPage::CPrinterOptionsPropPageFactory::UpdateRegistry -
rrocx\printppg.cpp:// Adds or removes system registry entries for CPrinterOptionsPropPage
rrocx\printppg.cpp:BOOL CPrinterOptionsPropPage::CPrinterOptionsPropPageFactory::UpdateRegistry(BOOL bRegister)
rrocx\printppg.cpp:		return AfxOleRegisterPropertyPageClass ( AfxGetInstanceHandle(), m_clsid, IDS_PRINTER_PPG ) ;
rrocx\printppg.cpp:		return AfxOleRegisterPropertyPageClass ( AfxGetInstanceHandle(), m_clsid, IDS_ARPPRINTER_PPG ) ;
rrocx\printppg.cpp:// CPrinterOptionsPropPage::CPrinterOptionsPropPage - Constructor
rrocx\printppg.cpp:CPrinterOptionsPropPage::CPrinterOptionsPropPage() : COlePropertyPage(IDD, IDS_PRINTER_PPG_CAPTION)
rrocx\printppg.cpp:CPrinterOptionsPropPage::CPrinterOptionsPropPage() : COlePropertyPage(IDD, IDS_ARPPRINTER_PPG_CAPTION)
rrocx\printppg.cpp:	//{{AFX_DATA_INIT(CPrinterOptionsPropPage)
rrocx\printppg.cpp:	m_iCopiesToPrinter = 1         ;
rrocx\printppg.cpp:	m_iPrinter         = 0         ;
rrocx\printppg.cpp:int CPrinterOptionsPropPage::GetPageSizeValue(CDataExchange* pDX)
rrocx\printppg.cpp:void CPrinterOptionsPropPage::SetPageSizeValue(CDataExchange* pDX, int *nPageSize)
rrocx\printppg.cpp:// CPrinterOptionsPropPage::DoDataExchange - Moves data between page and properties
rrocx\printppg.cpp:void CPrinterOptionsPropPage::DoDataExchange(CDataExchange* pDX)
rrocx\printppg.cpp:	//{{AFX_DATA_MAP(CPrinterOptionsPropPage)
rrocx\printppg.cpp:	DDP_Text (pDX, IDC_NUMCOPIES, m_iCopiesToPrinter,     _T("CopiesToPrinter") ) ;
rrocx\printppg.cpp:	DDX_Text (pDX, IDC_NUMCOPIES, m_iCopiesToPrinter) ;
rrocx\printppg.cpp:	DDV_MinMaxInt(pDX, m_iCopiesToPrinter, 1, 99999) ;
rrocx\printppg.cpp:	// We need to get the value of the _T("Printer") before we know what to do with
rrocx\printppg.cpp:		// Get the value of the radio button and then the printer value.
rrocx\printppg.cpp:		DDX_Radio(pDX, IDC_SAVED, (int &)m_iPrinter) ;
rrocx\printppg.cpp:		if ( m_iPrinter == 0 )
rrocx\printppg.cpp:			m_strPrinter = _T("") ;
rrocx\printppg.cpp:		else if ( m_iPrinter == 1 )
rrocx\printppg.cpp:			m_strPrinter = _T("?") ;
rrocx\printppg.cpp:			DDX_Text(pDX, IDC_OPRINTER, m_strPrinter) ;
rrocx\printppg.cpp:			// See if the printer name is specified, if it isn't return an error
rrocx\printppg.cpp:			if (((CEdit *)GetDlgItem(IDC_OPRINTER))->LineLength() == 0) {
rrocx\printppg.cpp:				CText.LoadString(IDS_NoPrinter_ErrorMsg);
rrocx\printppg.cpp:				CTitle.LoadString(IDS_NoPrinter_ErrorMsg_Title);
rrocx\printppg.cpp:		UpdateControl ( this, _T("Printer"), VT_BSTR, &m_strPrinter ) ;
rrocx\printppg.cpp:		// and hardcode the DISPID's for the Printer and Port Property
rrocx\printppg.cpp://		ddPropDispDriver.SetProperty ( 20, /*dwDispId for "Printer" property*/ VT_BSTR, m_strPrinter  ) ;
rrocx\printppg.cpp:		// If we arent saving the value, then get the value of Printer from the control and based
rrocx\printppg.cpp:		RetrieveControl ( this, _T("Printer"), VT_BSTR, &m_strPrinter ) ;
rrocx\printppg.cpp:		// and hardcode the DISPID's for the Printer and Port Property
rrocx\printppg.cpp://		ddPropDispDriver.GetProperty ( 20, /*dwDispId for "Printer" property*/ VT_BSTR, &m_strPrinter  ) ;
rrocx\printppg.cpp:		if ( m_strPrinter.IsEmpty() )
rrocx\printppg.cpp:			m_iPrinter = 0 ;
rrocx\printppg.cpp:		else if ( m_strPrinter == _T("?") )
rrocx\printppg.cpp:			m_iPrinter   = 1 ;
rrocx\printppg.cpp:			m_strPrinter = _T("") ;
rrocx\printppg.cpp:			m_iPrinter = 2 ;
rrocx\printppg.cpp:		// After we set the value of the printer and radio button, set the values in the PPG
rrocx\printppg.cpp:		DDX_Radio(pDX, IDC_SAVED,    m_iPrinter  ) ;
rrocx\printppg.cpp:		DDX_Text (pDX, IDC_OPRINTER, m_strPrinter) ;
rrocx\printppg.cpp:// CPrinterOptionsPropPage message handlers
rrocx\printppg.cpp:BOOL CPrinterOptionsPropPage::OnInitDialog() 
rrocx\printppg.cpp:	// printer is entered
rrocx\printppg.cpp:	if ( m_iPrinter==0 || m_iPrinter==1 )
rrocx\printppg.cpp:		CWnd* pwndPrinterDest   = GetDlgItem ( IDC_OPRINTER       ) ;
rrocx\printppg.cpp:		CWnd* pwndBrowsePrinter = GetDlgItem ( IDC_BROWSE_PRINTER ) ;
rrocx\printppg.cpp:		ASSERT( pwndPrinterDest   );
rrocx\printppg.cpp:		ASSERT( pwndBrowsePrinter );
rrocx\printppg.cpp:		pwndPrinterDest->EnableWindow   ( FALSE  ) ;
rrocx\printppg.cpp:		pwndPrinterDest->SetWindowText  ( _T("") ) ;
rrocx\printppg.cpp:		pwndBrowsePrinter->EnableWindow ( FALSE  ) ;
rrocx\printppg.cpp:void CPrinterOptionsPropPage::OnShowWindow(BOOL bShow, UINT nStatus) 
rrocx\printppg.cpp:void CPrinterOptionsPropPage::OnBrowsePrinter() 
rrocx\printppg.cpp:	char szTempString[256] ;  // error string/printer string
rrocx\printppg.cpp:	// We need to call  the runtime DLL choosePrinter function here.
rrocx\printppg.cpp:	// Get an empty report handle, get the printer, then leave.
rrocx\printppg.cpp:	if ( !(choosePrinter(reportHandle, szTempString, sizeof(szTempString), szPort, sizeof(szPort))) )
rrocx\printppg.cpp:			strncat ( szTempString, _T(" ; While choosing a printer"), sizeof(szTempString) ) ;
rrocx\printppg.cpp:	{	// Set the printer and the port.  Then update the values in the PPG
rrocx\printppg.cpp:		m_strPrinter = szTempString ;
rrocx\printppg.cpp:		SetControlStatus ( IDC_OPRINTER, TRUE ) ;
rrocx\printppg.cpp:		CWnd* pwndPrinter = GetDlgItem ( IDC_OPRINTER ) ;
rrocx\printppg.cpp:		ASSERT( pwndPrinter );
rrocx\printppg.cpp:		pwndPrinter->SetWindowText ( m_strPrinter ) ;
rrocx\printppg.cpp:void CPrinterOptionsPropPage::OnOverride() 
rrocx\printppg.cpp:	//  the current printer (if you can) from the DLL.
rrocx\printppg.cpp:	CWnd* pwndPrinterDest   = GetDlgItem(IDC_OPRINTER) ;
rrocx\printppg.cpp:	CWnd* pwndBrowsePrinter = GetDlgItem(IDC_BROWSE_PRINTER) ;
rrocx\printppg.cpp:	ASSERT( pwndPrinterDest   );
rrocx\printppg.cpp:	ASSERT( pwndPrinterDest   );
rrocx\printppg.cpp:	pwndPrinterDest->EnableWindow(TRUE) ;
rrocx\printppg.cpp:	pwndBrowsePrinter->EnableWindow(TRUE) ;
rrocx\printppg.cpp:	m_strPrinter = _T("") ;
rrocx\printppg.cpp:	// Don't set the printer string to empty if it is all ready empty or else
rrocx\printppg.cpp:	if (!m_strPrinter.IsEmpty())
rrocx\printppg.cpp:		pwndPrinterDest->SetWindowText(m_strPrinter);
rrocx\printppg.cpp:	pwndPrinterDest->SetFocus();
rrocx\printppg.cpp:void CPrinterOptionsPropPage::OnPrompt() 
rrocx\printppg.cpp:	CWnd* pwndPrinterDest   = GetDlgItem(IDC_OPRINTER) ;
rrocx\printppg.cpp:	CWnd* pwndBrowsePrinter = GetDlgItem(IDC_BROWSE_PRINTER) ;
rrocx\printppg.cpp:	ASSERT( pwndPrinterDest   );
rrocx\printppg.cpp:	ASSERT( pwndPrinterDest   );
rrocx\printppg.cpp:	pwndPrinterDest->EnableWindow(FALSE) ;
rrocx\printppg.cpp:	m_strPrinter = _T("?") ;
rrocx\printppg.cpp:	pwndPrinterDest->SetWindowText(_T("")) ;
rrocx\printppg.cpp:	pwndBrowsePrinter->EnableWindow(FALSE) ;
rrocx\printppg.cpp:void CPrinterOptionsPropPage::OnSaved() 
rrocx\printppg.cpp:	CWnd* pwndPrinterDest   = GetDlgItem(IDC_OPRINTER) ;
rrocx\printppg.cpp:	CWnd* pwndBrowsePrinter = GetDlgItem(IDC_BROWSE_PRINTER) ;
rrocx\printppg.cpp:	ASSERT( pwndPrinterDest   );
rrocx\printppg.cpp:	ASSERT( pwndPrinterDest   );
rrocx\printppg.cpp:	pwndPrinterDest->EnableWindow(FALSE) ;
rrocx\printppg.cpp:	m_strPrinter = _T("") ;
rrocx\printppg.cpp:	pwndPrinterDest->SetWindowText(_T("")) ;
rrocx\printppg.cpp:	pwndBrowsePrinter->EnableWindow(FALSE) ;
rrocx\printtop.cpp:	ON_BN_CLICKED(IDC_PRINTER,         OnPrinter       )
rrocx\printtop.cpp:	else if ( m_enumDestination == destPRINTER ) nDestination = 2 ;
rrocx\printtop.cpp:			*destOptionsOut = destPRINTER            ;
rrocx\printtop.cpp:void CPrintToPropPage::OnPrinter() 
rrocx\rrocxppg.cpp:// we dont really want to get the reports value of Printer.  We instead want to
rrocx\rrocxppg.cpp:// set it to _T(""), so that the user will see _T("Use saved printer") in the printerPPG
rrocx\rsw\rsdbppg.cpp:	char szTempString[256] ;  // error string/printer string
rrocx\rsw\rswctl.cpp:#include "..\printppg.h"  // CPrinterOptionsPropPage
rrocx\rsw\rswctl.cpp:	DISP_PROPERTY_EX(CRrocxCtrl, "CopiesToPrinter",     GetCopiesToPrinter,     SetCopiesToPrinter,      VT_I2   )
rrocx\rsw\rswctl.cpp:	DISP_PROPERTY_EX(CRrocxCtrl, "Printer",             GetPrinter,             SetPrinter,              VT_BSTR )
rrocx\rsw\rswctl.cpp:	PROPPAGEID(CPrinterOptionsPropPage::guid)
rrocx\rsw\rswctl.cpp:	PROPPAGEID(CPrinterOptionsPropPage::guid)
rrocx\rsw\rswctl.cpp:	PX_Short (pPX, _T("CopiesToPrinter"   ), m_iCopiesToPrinter,      1        ) ;
rrocx\rsw\rswctl.cpp:	PX_String(pPX, _T("Printer"           ), m_strPrinter                      ) ;
rrocx\rsw\rswctl.cpp:	m_iCopiesToPrinter      = 1      ;  // 1 copy is the default
rrocx\rsw\rswctl.cpp:	m_strPrinter            = _T("") ;
rrocx\rsw\rswctl.cpp:	m_iCopiesToPrinter      = 1      ;  // 1 copy is the default
rrocx\rsw\rswctl.cpp:	m_strPrinter            = _T("") ;
rrocx\rsw\rsrelppg.cpp:	char szTempString[256] ;  // error string/printer string
rrocx\rrw\rrwctl.cpp:#include "..\printppg.h"  // CPrinterOptionsPropPage
rrocx\rrw\rrwctl.cpp:	DISP_PROPERTY_EX(CRrocxCtrl, "CopiesToPrinter",     GetCopiesToPrinter,     SetCopiesToPrinter,      VT_I2   )
rrocx\rrw\rrwctl.cpp:	DISP_PROPERTY_EX(CRrocxCtrl, "Printer",             GetPrinter,             SetPrinter,              VT_BSTR )
rrocx\rrw\rrwctl.cpp:	PROPPAGEID(CPrinterOptionsPropPage::guid)
rrocx\rrw\rrwctl.cpp:	PX_Short (pPX, _T("CopiesToPrinter"   ), m_iCopiesToPrinter,      1        ) ;
rrocx\rrw\rrwctl.cpp:	PX_String(pPX, _T("Printer"           ), m_strPrinter                      ) ;
rrocx\rrw\rrwctl.cpp:	m_iCopiesToPrinter      = 1      ;  // 1 copy is the default
rrocx\rrw\rrwctl.cpp:	m_strPrinter            = _T("") ;
rrocx\rrw\rrwctl.cpp:	m_iCopiesToPrinter      = 1      ;  // 1 copy is the default
rrocx\rrw\rrwctl.cpp:	m_strPrinter            = _T("") ;
RR\mainfrm.cpp:// Don't free the printer driver unless it was loaded.
RR\mainfrm.cpp:// Ignore Device Broadcast if it does not contain a header.  Adding a printer 
RR\mainfrm.cpp:	// Don't free the printer driver unless it was loaded. 
RR\mainfrm.cpp:	if ( m_pFieldView->m_pDoc->hPrinterDriver )
RR\mainfrm.cpp:		FreeLibrary(m_pFieldView->m_pDoc->hPrinterDriver);	// and printer driver
RR\mainfrm.cpp:	if (m_pFieldView->m_pDoc->hPDFPrinterDriver )
RR\mainfrm.cpp:		fend = (PDFEND)GetProcAddress(m_pFieldView->m_pDoc->hPDFPrinterDriver, "DriverEnd") ;
RR\mainfrm.cpp:		(*fend)(m_pFieldView->m_pDoc->hPDFPrinter) ;
RR\mainfrm.cpp:		FreeLibrary(m_pFieldView->m_pDoc->hPDFPrinterDriver) ;
RR\mainfrm.cpp:		m_pFieldView->m_pDoc->checkPrtChange();		// check for printer change
RR\mainfrm.cpp:	// Adding a printer caused this even with wParam=7 and lParam=0. 
RR\mainfrm.cpp:	m_pFieldView->m_pDoc->checkPrtChange();		// check for printer change
RR\rrcompos.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
RR\rrdoc.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
RR\rrdoc.cpp:   hPrinterDriver = (HINSTANCE)0;   // our current printer driver instance
RR\rrdoc.cpp:   NumPrtFaces = 0;           // number of printer typefaces
RR\rrdoc.cpp:   PDevMode = (LPDEVMODE)NULL;   // current printer device mode
RR\rrdoc.cpp:   PrintCopies = 0;           // printer copies
RR\rrdoc.cpp:   *PrintDrv = 0;             // current printer driver
RR\rrdoc.cpp:   PrinterInchX = 0;          // horizontal printer resolution
RR\rrdoc.cpp:   PrinterInchY = 0;          // vertical printer resolution
RR\rrdoc.cpp:   *PrintPort = 0;               // current printer port
RR\rrdoc.cpp:   *PrintType = 0;               // current printer type
RR\rrdoc.cpp:   PrState = 0;               // report writer printer status
RR\rrdoc.cpp:   PrtStruct = (LPPRT_STRUCT)NULL; // printer structure
RR\rrrepio.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
PIC\picdata.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
PIC\picdata.cpp:			LPFNPWDOTWIDTH lpfnDotWidth = (LPFNPWDOTWIDTH)GetProcAddress(hPrinterDriver,MAKEINTRESOURCE(PWDOTWIDTH));
PIC\picdata.cpp:			LPFNPWCHARWIDTH lpfnCharWidth = (LPFNPWCHARWIDTH)GetProcAddress(hPrinterDriver,MAKEINTRESOURCE(PWCHARWIDTH));
PIC\picdata.cpp:			LPFNPWFINDATT lpfnFindAtt = (LPFNPWFINDATT)GetProcAddress(hPrinterDriver,MAKEINTRESOURCE(PWFINDATT));
PIC\picshape.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
RRWCNVRT\pass1.cpp:// Bug 2123: extract printer number from yxPRINTER record for use
RRWCNVRT\pass1.cpp:	char prtNumC[2];	// printer port number in ASCII
RRWCNVRT\pass1.cpp:		// remember printer port
RRWCNVRT\pass1.cpp:		case yxPRINTER:
RRWCNVRT\convert.cpp://-	gimme printers/fifs 
RRWCNVRT\fixrecs.cpp:			case yxPRINTER:
RRWCNVRT\fixrecs.cpp:			case yxPRINTER:
RRWCNVRT\fixrecs.cpp:				ii = fixstr(&buf.yxRec[0]);			// printer name
RRWCNVRT\rp5_rp1.cpp:// Bug 2123: add printer number to yxOPTS1.
RRWCNVRT\rp5_rp1.cpp:		case yxPRINTER:
RRWCNVRT\rp5_rp1.cpp:			buf.yxRec[3] = prtNum;		// use real printer number
WLAYOUT\wpix.cpp:// New HTML export structure was integrated into printer driver.
WLAYOUT\wfont.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
WLAYOUT\wfont.cpp:// used to load fonts if there are no printers installed
WLAYOUT\wfont.cpp:// Changes for PDI export w/o printer
WLAYOUT\wfont.cpp:// If CreateIC() fails in initFonts(), then resort to default printer instead
WLAYOUT\wfont.cpp:// find first printer font in list, if any
WLAYOUT\wfont.cpp:		if (PrtFonts[i].flags & PRINTER_FONT)
WLAYOUT\wfont.cpp:	{ // printer fonts available - use default if possible
WLAYOUT\wfont.cpp:// Look for typeface in special list (PDI export w/o printer)
WLAYOUT\wfont.cpp:// Store typefaces for PDI export w/o printer
WLAYOUT\wfont.cpp:	{ // PDI export w/o printer, need to salvage typeface names
WLAYOUT\wfont.cpp:void CRrDoc::deleteFonts(BOOL bSetDef)			// exit or printer change
WLAYOUT\wfont.cpp:	{ // don't bother if no printer
WLAYOUT\wfont.cpp:			pDoc->PrtFonts[pDoc->fontIndex].flags |= PRINTER_FONT;
WLAYOUT\wfont.cpp:	size = ((tm->tmHeight-tm->tmInternalLeading) * POINTSIZE) / pDoc->PrinterInchY;
WLAYOUT\wfont.cpp:extern LPDEVMODE getDevMode(LPTSTR pPrinterName) ;
WLAYOUT\wfont.cpp:		{ // bad printer, try default
WLAYOUT\wfont.cpp:			getPrinterDriver( TRUE );
WLAYOUT\wfont.cpp:		{ // got a printer, now check fonts
WLAYOUT\wfont.cpp:			PrinterInchX = GetDeviceCaps( pDC, LOGPIXELSX );
WLAYOUT\wfont.cpp:			PrinterInchY = GetDeviceCaps( pDC, LOGPIXELSY );
WLAYOUT\wfont.cpp:			//TRACE( "  initFonts()  %s has (%d,%d) DPI\n", PrintType, (int) PrinterInchX, (int) PrinterInchY ) ;
WLAYOUT\wfont.cpp:	// SP 1/8/97 used to load fonts if there are no printers installed
WLAYOUT\wfont.cpp:	// This check is needed because a printer could be retieved from the report
WLAYOUT\wfont.cpp:	// but there is not a printer on the current machine so, the if (!PrtFonts && PrintType[0])
WLAYOUT\wfont.cpp:	// retrieve the fonts from the system without using the printer.
WLAYOUT\wfont.cpp:		// the fonts were not retrieved and there is no printer
WLAYOUT\wfont.cpp:// SP 1/8/97 used to load fonts if there are no printers installed
WLAYOUT\wfont.cpp:	PrinterInchX = GetDeviceCaps( pDC, LOGPIXELSX );
WLAYOUT\wfont.cpp:	PrinterInchY = GetDeviceCaps( pDC, LOGPIXELSY );
WLAYOUT\wfont.cpp:void CRrDoc::fontChange(BOOL fixflds)		// printer driver change
PD\wexpint.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
PD\wexpint.cpp:/*	This routine corresponds to the wpd routine screenToPrinterX (in pwint.c)
PD\wexpint.cpp:// output a line to display or printer
PD\memdlg.cpp:// the support to print the ole object records inside the printer driver.
PD\memdlg.cpp:// Converted the printer driver to an MFC Extension DLL.
PD\memdlg.cpp:// Printer driver modules are about to be ported to MFC.
PD\memdlg.cpp:#include "product.h"  // Special version just for printer driver. 
PD\rtfxint.cpp:	int pSize = MulDiv(WEXPPS.pSize.x,1440,WEXPPS.printerInchX);
PD\rtfxint.cpp:	int pHeight =	MulDiv(WEXPPS.pSize.y,1440,WEXPPS.printerInchY);
PD\rtfxint.cpp:		MulDiv(REXPPS.leftMarg,1440,WEXPPS.printerInchX),
PD\rtfxint.cpp:		MulDiv(REXPPS.topMarg,1440,WEXPPS.printerInchY),
PD\rtfxint.cpp:		MulDiv ( REXPPS.topMarg, 1440, WEXPPS.printerInchY));
PD\rtfxint.cpp://	This routine corresponds to the wpd routine screenToPrinterX (in pwint.c)
PD\rtfxint.cpp:// convert points to vertical printer resolution
PD\rtfxint.cpp:	return MulDiv(pts, WEXPPS.printerInchY, POINTSIZE * 10);
PD\rtfxint.cpp:				{ // check resources for printer
PD\pwdriver.cpp:// Windows File Print printer driver routines
PD\pwdriver.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
PD\pwdriver.cpp:// the support to print the ole object records inside the printer driver.
PD\pwdriver.cpp:// the printer driver.
PD\pwdriver.cpp:// Converted the printer driver to an MFC Extension DLL.
PD\pwdriver.cpp:// Printer driver modules are about to be ported to MFC.
PD\pwdriver.cpp:// Move guts of pwInit() to wprintui\wprint.cpp (initPrinter())
PD\pwdriver.cpp:#include "product.h"  // Special version just for printer driver. 
PD\pwdriver.cpp:// return width of character based on printer font
PD\pwdriver.cpp:// convert inches to printer resolution (e.g. dots)
PD\pwdriver.cpp:	return ((DWORD)MulDiv(ps->pDest.wpd.printerInchX, inches, 100));
PD\pwdriver.cpp:			VTRES, ps->pDest.wpd.printerInchY));
PD\pwdriver.cpp:	var = !lineAscent ? VTRES/6 : (!leading ? lineAscent : MulDiv(lineAscent, VTRES, ps->pDest.wpd.printerInchY));
PD\pwdriver.cpp:	return (MAKELONG(var,MulDiv(lineDescent, VTRES, ps->pDest.wpd.printerInchY)));
PD\pwdriver.cpp:// feed the paper to TOF (printer only)
PD\pwdriver.cpp:	{ // to printer only!
PD\pwdriver.cpp:		BOOL bDeleteDC = DeleteDC(ps->pDest.wpd.printDC);	  // remove printer context
PD\pxdriver.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
PD\pxdriver.cpp:// zero and no default printer.
PD\pxdriver.cpp:// Changes to support export w/o printer
PD\pxdriver.cpp:	{ // use printer values
PD\pxdriver.cpp:		fHdr.wPaperWidth = MulDiv( ps->pDest.wpd.pSize.x, HZRES, ps->pDest.wpd.printerInchX );
PD\pxdriver.cpp:		fHdr.wPaperHeight = MulDiv( ps->pDest.wpd.pSize.y, HZRES, ps->pDest.wpd.printerInchY );
PD\pxdriver.cpp:	{ // guess there's no printer available
PD\pxdriver.cpp:	// prepare for no printer/device context
PD\pxdriver.cpp:// Feed the paper to TOF (printer only)
PD\pxdriver.cpp:	{ // printer only for PDI export
PD\pxdriver.cpp:	{ // remove printer context
PD\pxdriver.cpp:// Return width of character based on printer font
PD\pxdriver.cpp:	// compute monospace width if no printer available
PD\pxdriver.cpp:	return ( ps->pDest.wpd.printerInchX / nCharsInch );
PD\pxdriver.cpp:// Convert inches to printer resolution (e.g. dots)
PD\pxdriver.cpp:	return (DWORD)MulDiv( ps->pDest.wpd.printerInchX, wInches, 100 );
PD\pxdriver.cpp:			VTRES, ps->pDest.wpd.printerInchY );
PD\pxdriver.cpp:	{ // no leading or no printer
PD\pxdriver.cpp:							{ // no leading or no printer
PD\pxdriver.cpp:								{ // got a printer
PD\pxdriver.cpp:								{ // no printer, wing it
PD\pxdriver.cpp:		MulDiv( nLineAscent, VTRES, ps->pDest.wpd.printerInchY ));
PD\pxdriver.cpp:	return MAKELONG( nValue, MulDiv( nLineDescent, VTRES, ps->pDest.wpd.printerInchY ));
PD\rtfexp.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
PD\rtfexp.cpp:// RRW 2968/RSW 2366: don't call CreateDC in RTF export if a printer
PD\rtfexp.cpp:// R?W Bug 2636: compensate for Windows printer orientation.
PD\rtfexp.cpp:// Adjust for change in expected return of printer init.
PD\rtfexp.cpp:	{ // compensate if the Windows printer orientation is landscape
PD\rtfexp.cpp:			VTRES, WEXPPS.printerInchX);
PD\rtfexp.cpp:			VTRES, WEXPPS.printerInchY);
PD\rtfexp.cpp:	// get left margin in printer resolution units
PD\rtfexp.cpp:	WEXPPS.leftMar = MulDiv(pi->leftmar, WEXPPS.printerInchX, 100);
PD\rtfexp.cpp:	WEXPPS.unTop = (WORD)MulDiv(WEXPPS.pOffset.y, VTRES, WEXPPS.printerInchY);
PD\rtfexp.cpp:	// convert to printer resolution units
PD\rtfexp.cpp:	REXPPS.topMarg = MulDiv(REXPPS.topMarg, WEXPPS.printerInchY, 100);
PD\rtfexp.cpp:// return width of character based on printer font
PD\rtfexp.cpp:// convert inches to printer resolution (e.g. dots)
PD\rtfexp.cpp:	return ((DWORD)MulDiv(WEXPPS.printerInchX, inches, 100));
PD\rtfexp.cpp:									VTRES, WEXPPS.printerInchY));
PD\rtfexp.cpp:												MulDiv(lineAscent, VTRES, WEXPPS.printerInchY));
PD\rtfexp.cpp:	return (MAKELONG(var, MulDiv(lineDescent, VTRES, WEXPPS.printerInchY)));
PD\rtfexp.cpp:		DeleteDC(WEXPPS.printDC);	  // remove printer context
PD\htmlint.cpp:// Also no longer require a printer.
PD\htmlint.cpp://	This routine corresponds to the wpd routine screenToPrinterX (in pwint.c)
PD\htmlint.cpp:// convert points to vertical printer resolution
PD\htmlint.cpp:	return MulDiv(pts, HEXPPS.printerInchY, POINTSIZE * 10);
PD\htmlint.cpp:		// May not have a printer, and therefore no printDC
PD\htmlint.cpp:				{ // check resources for printer
PD\wexpdriv.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
PD\wexpdriv.cpp:// return width of character in device units based on printer font
PD\wexpdriv.cpp:// stubbed wpd\PWPREV.C Windows File Preview printer driver routines
PD\pwint.cpp:// Windows Print & Preview printer driver internal routines
PD\pwint.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
PD\pwint.cpp:// Use bFastPrint flag in printer structure, which is now set in EXE.  All this
PD\pwint.cpp:// Fixed problem with printing to printer.  The wrong DC was being used.
PD\pwint.cpp:// the support to print the ole object records inside the printer driver.
PD\pwint.cpp:// the printer driver.
PD\pwint.cpp:// Converted the printer driver to an MFC Extension DLL.
PD\pwint.cpp:// Printer driver modules are about to be ported to MFC.
PD\pwint.cpp:// Look for new overprint control (from INI file, for Generic printer)
PD\pwint.cpp:// Use saved rgb values for screen or printer for boxed.
PD\pwint.cpp:#include "product.h"  // Special version just for printer driver. 
PD\pwint.cpp:// convert points to vertical printer resolution
PD\pwint.cpp:	return (UINT)MulDiv(pts, ps->pDest.wpd.printerInchY, POINTSIZE * 10);
PD\pwint.cpp:// scale printer horizontal dimensions to screen dimensions
PD\pwint.cpp:// scale printer vertical dimensions to screen dimensions
PD\pwint.cpp:// horizontal screen resolution -> horizontal printer resolution
PD\pwint.cpp:UINT screenToPrinterX(LPPRT_STRUCT ps, UINT x)
PD\pwint.cpp:	return ((UINT)MulDiv(ps->pDest.wpd.printerInchX, x, ps->pDest.wpd.inchX));
PD\pwint.cpp:// vertical screen resolution -> vertical printer resolution
PD\pwint.cpp:UINT screenToPrinterY(LPPRT_STRUCT ps, UINT y)
PD\pwint.cpp:	return ((UINT)MulDiv(ps->pDest.wpd.printerInchY, y, ps->pDest.wpd.inchY));
PD\pwint.cpp:// horizontal screen resolution -> horizontal printer graphics resolution
PD\pwint.cpp:		ps->pDest.wpd.graphicsInchX = ps->pDest.wpd.printerInchX;
PD\pwint.cpp:	scale = (double)ps->pDest.wpd.printerInchX / ps->pDest.wpd.graphicsInchX;
PD\pwint.cpp:	return (screenToPrinterX(ps, x) / scale);
PD\pwint.cpp:// vertical screen resolution -> vertical printer graphics resolution
PD\pwint.cpp:		ps->pDest.wpd.graphicsInchY = ps->pDest.wpd.printerInchY;
PD\pwint.cpp:	scale = ps->pDest.wpd.printerInchY / ps->pDest.wpd.graphicsInchY;
PD\pwint.cpp:	return (screenToPrinterY(ps,y) / scale);
PD\pwint.cpp:// output a line of text to display or printer  
PD\pwint.cpp:						var = screenToPrinterX(ps, var);
PD\pwint.cpp:						ydelta = screenToPrinterY(ps, var);
PD\pwint.cpp:						pget2(ps, &var);	// get width in printer dots
PD\pwint.cpp:						var = screenToPrinterX(ps, var);
PD\pwint.cpp:				yLoc = MulDiv(ps->pDest.wpd.yPos, ps->pDest.wpd.printerInchY, VTRES);
PD\pwint.cpp:// output images to display or printer
PD\pwint.cpp:	int imgX    = screenToPrinterX ( ps, pImg->x    ) ;
PD\pwint.cpp:	int imgWid  = screenToPrinterX ( ps, pImg->wid  ) ;
PD\pwint.cpp:	int imgHite = screenToPrinterY ( ps, pImg->hite ) ;
PD\pwint.cpp:	// This version lets printer driver do scaling, dithering, etc.
PD\pwint.cpp:// output charts to display or printer
PD\pwint.cpp:	int chartX    = screenToPrinterX ( ps, pChart->x) ;
PD\pwint.cpp:	int chartWid  = screenToPrinterX ( ps, pChart->wWidth) ;
PD\pwint.cpp:	int chartHite = screenToPrinterY ( ps, pChart->wHeight) ;
PD\pwint.cpp:	// send to printer
PD\pwint.cpp:// output images to display or printer
PD\pwint.cpp:	int imgX    = screenToPrinterX ( ps, pObj->x       ) ;
PD\pwint.cpp:	int imgWid  = screenToPrinterX ( ps, pObj->wWidth  ) ;
PD\pwint.cpp:	int imgHite = screenToPrinterY ( ps, pObj->wHeight ) ;
PD\pwint.cpp:// output boxes to display or printer
PD\pwint.cpp:	// mjs 9/12/94  Use screen or printer colors.
PD\pwint.cpp:	hatchBack = 0x00ffffff; // White hatch background at the printer.
PD\dll.cpp:// the support to print the ole object records inside the printer driver.
PD\dll.cpp:// Converted the printer driver to an MFC Extension DLL.
PD\dll.cpp:// Printer driver modules are about to be ported to MFC.
PD\dll.cpp:#include "product.h"  // Special version just for printer driver. 
PD\htmlexp.cpp:// New HTML export structure was integrated into printer driver.
PD\htmlexp.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
PD\htmlexp.cpp:// When no printer, leave page length in points.
PD\htmlexp.cpp:// Also no longer require a printer
PD\htmlexp.cpp:		// no printer, assume some defaults
PD\htmlexp.cpp:		{ // compensate if the Windows printer orientation is landscape
PD\htmlexp.cpp:				VTRES, ps->pDest.html.printerInchX);
PD\htmlexp.cpp:				VTRES, ps->pDest.html.printerInchY);
PD\htmlexp.cpp:		// get left margin in printer resolution units
PD\htmlexp.cpp:		int leftMar = MulDiv(pi->leftmar, ps->pDest.html.printerInchX, 100);
PD\htmlexp.cpp:		ps->pDest.html.unTop = (WORD)MulDiv(pO.y, VTRES, ps->pDest.html.printerInchY);
PD\htmlexp.cpp:		// convert to printer resolution units
PD\htmlexp.cpp:		ps->pDest.html.topMarg = MulDiv(ps->pDest.html.topMarg, ps->pDest.html.printerInchY, 100);
PD\htmlexp.cpp:// return width of character based on printer font
PD\htmlexp.cpp:		// may not have a printer, and therefore no printDC
PD\htmlexp.cpp:// convert inches to printer resolution (e.g. dots)
PD\htmlexp.cpp:		return ((DWORD)MulDiv(ps->pDest.html.printerInchX, inches, 100));
PD\htmlexp.cpp:		// may not have a printer, and therefore no printDC
PD\htmlexp.cpp:									VTRES, ps->pDest.html.printerInchY));
PD\htmlexp.cpp:		// if no printer, assume default line height (like text export)
PD\htmlexp.cpp:												MulDiv(lineAscent, VTRES, ps->pDest.html.printerInchY));
PD\htmlexp.cpp:	return (MAKELONG(var, MulDiv(lineDescent, VTRES, ps->pDest.html.printerInchY)));
PD\htmlexp.cpp:		DeleteDC(ps->pDest.html.printDC);	  // remove printer context
PD\mem.cpp:// only by the printer driver code, since under low memory conditions, a message
PD\mem.cpp:// the support to print the ole object records inside the printer driver.
PD\mem.cpp:// Converted the printer driver to an MFC Extension DLL.
PD\mem.cpp:// Printer driver modules are about to be ported to MFC.
PD\mem.cpp:#include "product.h"  // Special version just for printer driver. 
PD\pwprev.cpp:// Windows File Preview printer driver routines
PD\pwprev.cpp:// the support to print the ole object records inside the printer driver.
PD\pwprev.cpp:// the printer driver.
PD\pwprev.cpp:// Converted the printer driver to an MFC Extension DLL.
PD\pwprev.cpp:// Printer driver modules are about to be ported to MFC.
PD\pwprev.cpp:#include "product.h"  // Special version just for printer driver. 
PD\pxint.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
PD\pxint.cpp:// zero and no printer.
PD\pxint.cpp:// Changes to support export w/o printer
PD\pxint.cpp:// Convert points to vertical printer resolution
PD\pxint.cpp:	return (UINT)MulDiv( nPts, ps->pDest.wpd.printerInchY, POINTSIZE * 10 );
PD\pxint.cpp:	// be zero if no printer is configured.
PD\pxint.cpp:// Printer resolution -> 720ths
PD\pxint.cpp:	return ((UINT)MulDiv( HZRES, x, ps->pDest.wpd.printerInchX ));
PD\pxint.cpp:// Printer resolution -> 720ths
PD\pxint.cpp:	return ((UINT)MulDiv( VTRES, y, ps->pDest.wpd.printerInchY ));
PD\pxint.cpp:					{ // use DC - printer available
PD\pxint.cpp:			{ // use DC - printer available
PD\pxint.cpp:// Output a line of text to display or printer
PD\pxint.cpp:						getWord( ps, &nValue );	// get width in printer dots
PD\tblentry.cpp:// New HTML export structure was integrated into printer driver.
PD\tblentry.cpp:	// The pFrame class was NULL when doing RI_PRINTER=H test.
WREPORT\script.cpp:// Use default points size if no printer selected (column locations)
WREPORT\wrepfix.cpp:// Need printer & fonts to fix things
WREPORT\wrepfix.cpp:#include "wprintui.h"		// getPrinterDriver()
WREPORT\wrepfix.cpp:	  { // only try to get a printer if we ain't got one...
WREPORT\wrepfix.cpp:		getPrinterDriver(FALSE);	// the printer...
WREPORT\rpinit.cpp:	PrOpt[RPOUT] = PRINT;	// to printer only
WREPORT\winst.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
WREPORT\wreport.cpp:// Fix in rrwrun: Do not open saved printer if pending change with RI_WPTR set
WREPORT\wreport.cpp:// Only "open" new printer on File New if we don't got one already (unlikely)...
WREPORT\wreport.cpp:#include "wprintui.h"   // for getPrinterDriver (at least)
WREPORT\wreport.cpp:	  { // only try to get a printer if we ain't got one...
WREPORT\wreport.cpp:		getPrinterDriver(FALSE);	// the printer...
WREPORT\wreport.cpp:	fontChange(FALSE);	// check printer/fonts
WREPORT\wreport.cpp:	  { // only try to get a printer if we ain't got one...
WREPORT\wreport.cpp:		getPrinterDriver(FALSE);	// the printer...
rrsqlwiz\wizutil.cpp:	{ // whack it out to printer
CFMISC\trim.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
MFDATA\mfgetmch.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
MFDATA\mfgetmch.cpp:	LPFNPWFINDATT lpfnFindAtt = (LPFNPWFINDATT)GetProcAddress(m_pDoc->hPrinterDriver,MAKEINTRESOURCE(PWFINDATT));
MFDATA\RRW\mfrdnext.cpp://  Fixes a problem where we were calling printer driver DLLs during the
MFDATA\mfrdrec.cpp:// Fixes a problem where we were calling printer driver DLLs during the
MFDATA\RSW\mfsql.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
SETUP\postinst\rvpostin.cpp:	// write Export settings to both places in case you can see them in runtime w/ ri_printer=?
SETUP\postinst\rdpostin.cpp:	// write Export settings to both places in case you can see them in runtime w/ ri_printer=?
Fax\Fax.cpp:#include <winspool.h>	// for Win32 printer stuff
Fax\Fax.cpp:// If both Printer and Port are specified, but that combo is not
Fax\Fax.cpp:// in printer list, return an error.
Fax\Fax.cpp:	LPPRINTER_INFO_5  pInfo5 = NULL;
Fax\Fax.cpp:	LPPRINTER_INFO_4  pInfo4 = NULL;
Fax\Fax.cpp:		// If we cant get version information, assume the printer and
Fax\Fax.cpp:	{	// If we are doing win95, we use printerinfo5.
Fax\Fax.cpp:		if (!(EnumPrinters( PRINTER_ENUM_LOCAL, NULL, 5, (LPBYTE)pInfo5,
Fax\Fax.cpp:		{	// We should always take an error trying to get the printers because we specified a
Fax\Fax.cpp:			// 0( dwSize,5th parameter) for the amount of memory for the list of available printers.
Fax\Fax.cpp:			// We do this so the EnumPrinter will return the size needed in variable dwNeeded 
Fax\Fax.cpp:				//if (pInfo5 = (LPPRINTER_INFO_5)m_pDoc->globalAlloc( GHND, dwSize5 ))
Fax\Fax.cpp:				if (pInfo5 = (LPPRINTER_INFO_5)GlobalLock(hMem) )
Fax\Fax.cpp:					if (!(EnumPrinters( PRINTER_ENUM_LOCAL, NULL, 5, (LPBYTE)pInfo5,
Fax\Fax.cpp:					{	// Another error. Could not enumerate the available printers
Fax\Fax.cpp:						return FALSE ; // assume the printer and port are OK.
Fax\Fax.cpp:	{	// Not win95, use printerinfo4
Fax\Fax.cpp:		if (!(EnumPrinters( PRINTER_ENUM_CONNECTIONS, NULL, 4, (LPBYTE)pInfo4,
Fax\Fax.cpp:			// We should always take an error trying to get the printers because we specified a
Fax\Fax.cpp:			// 0( dwSize,5th parameter) for the amount of memory for the list of available printers.
Fax\Fax.cpp:			// We do this so the EnumPrinter will return the size needed in variable dwNeeded 
Fax\Fax.cpp:				//if (pInfo4 = (LPPRINTER_INFO_4)m_pDoc->globalAlloc( GHND, dwSize4 ))
Fax\Fax.cpp:				if (pInfo4 = (LPPRINTER_INFO_4)GlobalLock(hMem))
Fax\Fax.cpp:					if (!(EnumPrinters( PRINTER_ENUM_CONNECTIONS, NULL, 4, (LPBYTE)pInfo4,
Fax\Fax.cpp:						 // Another error. Could not enumerate the available printers
Fax\Fax.cpp:						return FALSE ; // assume the printer and port are OK.
Fax\Fax.cpp:				m_csFaxDevice = pInfo5[ii].pPrinterName;
Fax\Fax.cpp:			csFaxPort = pInfo4[ii].pPrinterName;
Fax\Fax.cpp:				m_csFaxDevice = pInfo4[ii].pPrinterName;
Fax\Fax.cpp:/*		Sets the current doc object Printer and Port to the fax/modem device, minimizes	*/
Fax\Fax.cpp:/*		the frame, calls the doc's print routine and then resets the printer/port back	*/
Fax\Fax.cpp:		//Reset the Printer defaults
Fax\Fax.cpp:		// get printer info the MFC way...
REPIO\grmain.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
REPIO\rpwritex.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
REPIO\rpwritex.cpp:// and HTML value in the RI_PRINTER field.
REPIO\rpwritex.cpp:// printer
REPIO\rpwritex.cpp:	  { // printer installed, save it
REPIO\rpwritex.cpp:		if (yxput(yxPRINTER,off-data,data))
REPIO\rpwritex.cpp:		data[3] = m_pDoc->PrOpt[PRTR];			/* printer number */
REPIO\grfield.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
REPIO\grmisc.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
REPIO\grmisc.cpp:// and HTML value in the RI_PRINTER field.
REPIO\grmisc.cpp:	case yxPRINTER:                   // printer/driver/port
REPIO\gropts.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
REPIO\gropts.cpp://  printer instead of file in those cases with old DOS reports.
REPIO\gropts.cpp:			m_pDoc->PrOpt[PRTR] = buf->yxRec[3];		/* printer number */
WTOOLS\toolbars.cpp:// Change command ID of printer button (prints directly now)
DOPTIONS\dglobdef.cpp:			{ // got a printer, get the sizes
RUNTIME\wnextjob.cpp:// Added code for right-click send to printer
RUNTIME\wnextjob.cpp:// and HTML value in the RI_PRINTER field.
RUNTIME\wnextjob.cpp:// Database export:  Look for 'D', 'W', and 'T' in RI_PRINTER for dbf, wks, and
RUNTIME\wnextjob.cpp:// RpWPtr - 	Windows Printer
RUNTIME\wnextjob.cpp://														"P" (printer, will use RI_WPTR if present)
RUNTIME\wnextjob.cpp:	// RI_PRINTER
RUNTIME\wnextjob.cpp:		|| (!lstrcmpi(tempBuf, "WKS")))	//For WO#151768  multi character RI_PRINTER field
RUNTIME\wnextjob.cpp:		   break;		// 0 means use saved printer number
RUNTIME\wnextjob.cpp:			RpPrnNo = RTNOCODES;	// no printer codes
RUNTIME\wnextjob.cpp:		case 'p': case 'P':         // mjs 7/9/93  Force destination to be a printer.
RUNTIME\wnextjob.cpp:			// "Invalid printer indicator: %c"
RUNTIME\wnextjob.cpp:	fld = findfield(T6ARun);						// RI_PRINTER
RUNTIME\wnextjob.cpp:		|| (!lstrcmpi(fld->dFldP, "WKS")))			// For WO#151768  multi character RI_PRINTER field				
RUNTIME\wnextjob.cpp:				break;			// 0 means use saved printer number
RUNTIME\wnextjob.cpp:				RpPrnNo = RTNOCODES;	// no printer codes
RUNTIME\wnextjob.cpp:	//			RpPrnNo = WKSEX;		// no printer codes
RUNTIME\wnextjob.cpp:			case 'P':					// mjs 7/9/93  Force destination to be a printer.
RUNTIME\wnextjob.cpp:				return m_pDoc->zacknum(getString(IDS_1007,0),(LONG)RpPrnNo); // "Invalid printer indicator: %c"
RUNTIME\wnextjob.cpp:T6ARun, 		// RI_PRINTER
RUNTIME\wnextjob.cpp:	swrstr(T6ARun,JF_PRINTER);					// RI_PRINTER
RUNTIME\wnextjob.cpp:		case JF_PRINTER:
RUNTIME\wnextjob.cpp:			//	RpPrnNo = *buf;								// RI_PRINTER //ADDED WO151768
RUNTIME\wnextjob.cpp:				// "Invalid printer indicator: %c"
RUNTIME\wnextjob.cpp:					|| (!lstrcmpi(buf, "WKS")))	//For WO#151768  multi character RI_PRINTER field
RUNTIME\wnextjob.cpp:					break;											// 0 means use saved printer number
RUNTIME\wnextjob.cpp:				case 'p':  case 'P':                    // mjs 7/9/93  Force destination to be a printer.
RUNTIME\wnextjob.cpp:					// "Invalid printer indicator: %c"
RUNTIME\wnextjob.cpp://AMH 11/11/96 Added this moethod to the CRrRuntime class for right click send to printer
RUNTIME\wnextjob.cpp:BOOL CRrRuntime::SendToPrinter(void)
RUNTIME\wnextjob.cpp:	//Print to Printer
RUNTIME\wrtmain.cpp:// Fixed code so that Right-Click Send to Printer only uses the /N parameter
RUNTIME\wrtmain.cpp:// Added code for right-click send to printer
RUNTIME\wrtmain.cpp:		if(!runtimeJob.SendToPrinter())
RUNTIME\wrtmain.cpp:		if(!runtimeJob.SendToPrinter())
RUNTIME\wrtmain.cpp:	// for the printer driver DLL, if this fails make sure we unload the
RUNTIME\wrtmain.cpp:	pDoc->hPrinterDriver = LoadAndCheckLibrary ( m_elmFileManager.GetDefaultPrinterDriver(),
RUNTIME\wrtmain.cpp:	if ( pDoc->hPrinterDriver == NULL)
RUNTIME\wrtmain.cpp:		return FALSE;	  // no printer driver, no app
RUNTIME\wrtmain.cpp:			// N => Send to printer
RUNTIME\wrtmain.cpp:				//Set Flag telling app to send output to printer only
RUNTIME\wrun.cpp://      RpPrnNo:                        printer number (STILL VALID??)
RUNTIME\wrun.cpp:// When RI_WPTR=Default, override the report printer with the current
RUNTIME\wrun.cpp:// windows default printer.
RUNTIME\wrun.cpp:// Fixed RSW 2345 local printer problem. The code was correct. However, somehow 
RUNTIME\wrun.cpp:// it can not get the local printer information under NT 4.0. Added enumerating
RUNTIME\wrun.cpp:// available local printers code to work around. This may a VC++ 4.1 bug.
RUNTIME\wrun.cpp:// Comment out error if no printer available (PDI export)
RUNTIME\wrun.cpp:// and HTML value in the RI_PRINTER field.
RUNTIME\wrun.cpp:// Changed code so that we don't arbitrarily allocated space for 20 printers
RUNTIME\wrun.cpp:// Changed the EnumPrinter flag to PRINTER_ENUM_CONNECTIONS when in NT,
RUNTIME\wrun.cpp:// the pPrinterName member
RUNTIME\wrun.cpp:// I fixed a problem with the runtime when prompting for a printer.  The problem
RUNTIME\wrun.cpp:// was that we could not handle the number of printers returned from the call
RUNTIME\wrun.cpp:// if you had a lot of printers configured (the called failed and we gave up). I
RUNTIME\wrun.cpp:// put in some code to allocate the correct size printer struct.
RUNTIME\wrun.cpp:// This is part of a fix for RRW 2660.  You can now override the printer
RUNTIME\wrun.cpp:// Change askPrinter() to commonPrintDialog()
RUNTIME\wrun.cpp:// Fixed #1706 by using RI_OUTFILE even when RI_PRINTER is P or 1-8,
RUNTIME\wrun.cpp:#include "dfile.h"              // for askPrinter
RUNTIME\wrun.cpp:#include "wprintui.h"           // for getPrinterDriver & exportReport
RUNTIME\wrun.cpp:#include <winspool.h>   // for Win32 printer stuff
RUNTIME\wrun.cpp:	// override the printer with the current windows default. 
RUNTIME\wrun.cpp:		// 03/04/97 PAR.  If the user wants to switch to the default printer, 
RUNTIME\wrun.cpp:		// use the common print dialog to determine the default printer. 
RUNTIME\wrun.cpp:			TRACE( "  The report printer was %s on %s\n", m_pDoc->PrintType, m_pDoc->PrintPort );
RUNTIME\wrun.cpp:BOOL CRrRuntime::getRuntimeDriver(LPSTR pPrinter, LPSTR pPort)
RUNTIME\wrun.cpp:// If both Printer and Port are specified, but that combo is not
RUNTIME\wrun.cpp:// in printer list, return an error.
RUNTIME\wrun.cpp:	// let's try 20 printers worth...
RUNTIME\wrun.cpp:	LPPRINTER_INFO_5 pInfo5 = NULL ;
RUNTIME\wrun.cpp:	LPPRINTER_INFO_4 pInfo4 = NULL ;
RUNTIME\wrun.cpp:		// If we cant get version information, assume the printer and
RUNTIME\wrun.cpp:	{       // If we are doing win95, we use printerinfo5.
RUNTIME\wrun.cpp:		if (!(EnumPrinters( PRINTER_ENUM_LOCAL, NULL, 5, (LPBYTE)pInfo5,
RUNTIME\wrun.cpp:		{       // We should always take an error trying to get the printers because we specified a
RUNTIME\wrun.cpp:			// 0( dwSize,5th parameter) for the amount of memory for the list of available printers.
RUNTIME\wrun.cpp:			// We do this so the EnumPrinter will return the size needed in variable dwNeeded 
RUNTIME\wrun.cpp:				if (pInfo5 = (LPPRINTER_INFO_5)m_pDoc->globalAlloc( GHND, dwSize5 ))
RUNTIME\wrun.cpp:					if (!(EnumPrinters( PRINTER_ENUM_LOCAL, NULL, 5, (LPBYTE)pInfo5,
RUNTIME\wrun.cpp:					{       // Another error. Could not enumerate the available printers
RUNTIME\wrun.cpp:						return FALSE ; // assume the printer and port are OK.
RUNTIME\wrun.cpp:	{       // Not win95, use printerinfo4
RUNTIME\wrun.cpp:		if (!(EnumPrinters( PRINTER_ENUM_CONNECTIONS, NULL, 4, (LPBYTE)pInfo4,
RUNTIME\wrun.cpp:			// We should always take an error trying to get the printers because we specified a
RUNTIME\wrun.cpp:			// 0( dwSize,5th parameter) for the amount of memory for the list of available printers.
RUNTIME\wrun.cpp:			// We do this so the EnumPrinter will return the size needed in variable dwNeeded 
RUNTIME\wrun.cpp:				if (pInfo4 = (LPPRINTER_INFO_4)m_pDoc->globalAlloc( GHND, dwSize4 ))
RUNTIME\wrun.cpp:					if (!(EnumPrinters( PRINTER_ENUM_CONNECTIONS, NULL, 4, (LPBYTE)pInfo4,
RUNTIME\wrun.cpp:						 // Another error. Could not enumerate the available printers
RUNTIME\wrun.cpp:						return FALSE ; // assume the printer and port are OK.
RUNTIME\wrun.cpp:	CString         pPrinterName, pPortName ;
RUNTIME\wrun.cpp:			pPrinterName = pInfo5[ii].pPrinterName ;
RUNTIME\wrun.cpp:			pPrinterName = pInfo4[ii].pPrinterName ;
RUNTIME\wrun.cpp:		if (!strcmpi( pPrinterName, pPrinter ))
RUNTIME\wrun.cpp:		{ // printer match
RUNTIME\wrun.cpp:			if (!strcmpi( pPortName, pPort ) && (*pPrinter == 0))
RUNTIME\wrun.cpp:			{ // port matches and no printer - we'll take it
RUNTIME\wrun.cpp:	// HXC 1/1/97. Work around RSW 2345 local printer problem under NT 4.0.
RUNTIME\wrun.cpp:	// and sufficient to get both network and local printers. However,
RUNTIME\wrun.cpp:	// somehow it didn't get local printer driver info under NT Version 4.0.
RUNTIME\wrun.cpp:		LPPRINTER_INFO_4 pInfo4a = NULL ;
RUNTIME\wrun.cpp:		if (!(EnumPrinters( PRINTER_ENUM_LOCAL, NULL, 4, (LPBYTE)pInfo4a,
RUNTIME\wrun.cpp:			// We should always take an error trying to get the printers because we specified a
RUNTIME\wrun.cpp:			// 0( dwSize,5th parameter) for the amount of memory for the list of available printers.
RUNTIME\wrun.cpp:			// We do this so the EnumPrinter will return the size needed in variable dwNeeded 
RUNTIME\wrun.cpp:				if (pInfo4a = (LPPRINTER_INFO_4)m_pDoc->globalAlloc( GHND, dwSize4 ))
RUNTIME\wrun.cpp:					if (!(EnumPrinters( PRINTER_ENUM_LOCAL, NULL, 4, (LPBYTE)pInfo4a,
RUNTIME\wrun.cpp:						 // Another error. Could not enumerate the available printers
RUNTIME\wrun.cpp:						return FALSE ; // assume the printer and port are OK.
RUNTIME\wrun.cpp:			pPrinterName = pInfo4a[ii].pPrinterName ;
RUNTIME\wrun.cpp:			if (!strcmpi( pPrinterName, pPrinter ) || *pPrinter == 0)
RUNTIME\wrun.cpp:			{ // printer match or no printer
RUNTIME\wrun.cpp:		strcpy( m_pDoc->PrintType, pPrinterName );
RUNTIME\wrun.cpp:// If both Printer and Port are specified, but that combo is not
RUNTIME\wrun.cpp:	char szAllDevices[DEVICEMAX], szPrinter[PDRVSZ+PPORTSZ+1];
RUNTIME\wrun.cpp:		GetProfileString("devices", szPtr, "", szPrinter, sizeof szPrinter);
RUNTIME\wrun.cpp:		szDriver = strtok(szPrinter, ", ");
RUNTIME\wrun.cpp:		if (lstrcmpi((LPSTR)szPtr, pPrinter) == 0)
RUNTIME\wrun.cpp:			// Printer matches, and printing to a file - ignore port.
RUNTIME\wrun.cpp:				//      Printer matches and no port or port matches.
RUNTIME\wrun.cpp:				//      Port matches and no printer.
RUNTIME\wrun.cpp:					if (*pPrinter == 0)
RUNTIME\wrun.cpp:	// Printer or port were specified, but not found.
RUNTIME\wrun.cpp:	// Copy matching printer, driver, and port to globals.
RUNTIME\wrun.cpp:	m_pDoc->getPrinterDriver(TRUE);		// get current printer
RUNTIME\wrun.cpp:// mjs 6/17/92  Printer/Port overrides.
RUNTIME\wrun.cpp://      { // no printer, no PDI export
RUNTIME\wrun.cpp:// mjs 7/9/93  New feature: force output to printer.
RUNTIME\wrun.cpp:			m_pDoc->PrOpt[RPOUT] = PRINT;            // output to printer
RUNTIME\wrun.cpp:		// mjs 8/14/92  If printer saved in report no good, set one up.
RUNTIME\wrun.cpp:	m_pDoc->fontChange(FALSE);              // read in fonts for printer
rrrpt32\rdrepstf.cpp:// CBI (Canadian software company) having issues with mapped printers
rrrpt32\rdrepstf.cpp://	"RI_WPTR", 40, "", RDReport::getReportWprinter, TRUE,
rrrpt32\rdrepstf.cpp:// Foce RI_PRINTER=D  even if report says display
rrrpt32\rdrepstf.cpp:	"RI_PRINTER", 30, "", RDReport::getReportPrinter, TRUE,
rrrpt32\rdrepstf.cpp:	"RI_WPTR", 255, "", RDReport::getReportWprinter, TRUE,  //changed from 40
rrrpt32\rdrepstf.cpp:		// is needed because RI_OUTFILE is shared by printer output file and
rrrpt32\rdrepstf.cpp:		// depending on the current setting of RI_PRINTER, so if the caller changes
rrrpt32\rdrepstf.cpp:		// RI_PRINTER (via setOutputDest()), it should call getOutputFile() afterward to
rrrpt32\rdrepstf.cpp:		// only one control that's common to both the export file and the printer file,
rrrpt32\rdrepstf.cpp:						if (strcmp(*valName, "RI_PRINTER") != 0 &&  !strcmpi( repField->reportVal, *value ) )
rrrpt32\rdrepstf.cpp:	// We've got an RI_OUTFILE and no override; check RI_PRINTER to see which
rrrpt32\rdrepstf.cpp:	strcpy(riBuf, m_Util.getFString(IDS_RI_PRINTER, 2));	// use buffer 2 in case we were called with an arg in 0-1
rrrpt32\rdrepstf.cpp:		// use the printer outfile
rrrpt32\rdrepval.cpp:BOOL RDReport::getPrinter(
rrrpt32\rdrepval.cpp: char *printer,
rrrpt32\rdrepval.cpp:	return getCharValue (m_Util.getFString(IDS_RI_WPTR, 0), printer, pSize);		// handles errors	// "RI_WPTR"
rrrpt32\rdrepval.cpp:BOOL RDReport::setPrinter(
rrrpt32\rdrepval.cpp: LPCSTR printer
rrrpt32\rdrepval.cpp:	return setCharValue (m_Util.getFString(IDS_RI_WPTR, 0), printer);		// handles errors	// "RI_WPTR"
rrrpt32\rdrepval.cpp:BOOL RDReport::getPrinterPort(
rrrpt32\rdrepval.cpp:BOOL RDReport::setPrinterPort(
rrrpt32\rdrepval.cpp:	// RI_OUTFILE can be used for either export file or printer output file
rrrpt32\rdrepval.cpp:	// RI_OUTFILE can be used for either export file or printer output file
rrrpt32\rdrepval.cpp:	return getCharValue (m_Util.getFString(IDS_RI_PRINTER, 0), lpszDest, dSize);		// handles errors	// "RI_PRINTER"
rrrpt32\rdrepval.cpp:	return setCharValue (m_Util.getFString(IDS_RI_PRINTER, 0), (LPSTR)lpszDest);		// handles errors	// "RI_PRINTER"
rrrpt32\rdmisc.cpp:// Made choosePrinter return "User canceled" error message when he does.
rrrpt32\rdmisc.cpp:// Added hReport argument to choosePrinter() for consistency with other
rrrpt32\rdmisc.cpp:// Added buffer-size arguments to choosePrinter().
rrrpt32\rdmisc.cpp:const unsigned int PRINTERBYTES    = 80*20;
rrrpt32\rdmisc.cpp:RDReport::choosePrinter(
rrrpt32\rdmisc.cpp: LPSTR printer,
rrrpt32\rdmisc.cpp:	if (!printer || !port)
rrrpt32\rdmisc.cpp:	// Init printer, port, etc. to defaults
rrrpt32\rdmisc.cpp:	m_pDoc->getPrinterDriver( FALSE );
rrrpt32\rdmisc.cpp:		_fstrncpy(printer, (LPSTR)m_pDoc->PrintType, prSize);
rrrpt32\rdreport.cpp:BOOL RDReport::getReportPrinter(
rrrpt32\rdreport.cpp:									// produces a file containing printer codes.
rrrpt32\rdreport.cpp:BOOL RDReport::getReportWprinter(
rrrpt32\rdreport.cpp:	UTWO recTypes[2] = {yxPRINTER, 0};
rrrpt32\rdreport.cpp:	UTWO recTypes[2] = {yxPRINTER, 0};
rrrpt32\rdreport.cpp:		i = repVal[0];			// length of printer name
rrrpt32\cwrapper.cpp:// Added choosePrinter.
rrrpt32\cwrapper.cpp:BOOL RUNDLL_API choosePrinter(
rrrpt32\cwrapper.cpp: LPSTR printer,
rrrpt32\cwrapper.cpp:		ConvertSpacesToNullString( printer, prSize );
rrrpt32\cwrapper.cpp:		return pReport->choosePrinter( printer, prSize, port, poSize );
rrrpt32\cwrapper.cpp:BOOL RUNDLL_API getPrinter(
rrrpt32\cwrapper.cpp: LPSTR lpszPrinter,
rrrpt32\cwrapper.cpp:		ConvertSpacesToNullString( lpszPrinter, size );
rrrpt32\cwrapper.cpp:		return pReport->getPrinter( lpszPrinter, size );
rrrpt32\cwrapper.cpp:BOOL RUNDLL_API getPrinterPort(
rrrpt32\cwrapper.cpp:		return pReport->getPrinterPort( lpszPort, size );
rrrpt32\cwrapper.cpp:BOOL RUNDLL_API setPrinter(
rrrpt32\cwrapper.cpp: LPCSTR lpszPrinter
rrrpt32\cwrapper.cpp:		return pReport->setPrinter( lpszPrinter );
rrrpt32\cwrapper.cpp:BOOL RUNDLL_API setPrinterPort(
rrrpt32\cwrapper.cpp:		return pReport->setPrinterPort( lpszPort );
DFILE\dpropt.cpp:// Fix for printer margin settings
DFILE\dpropt.cpp:// Page setup will use the PDevMode to initialize the printer, so the printer properties
DFILE\dpropt.cpp:// changed by the printer dialog will be reflected.
DFILE\dpropt.cpp:// DocumentProperties requires the printer name not be NULL.
DFILE\dpropt.cpp:#include <winspool.h>	// for Win32 printer stuff
DFILE\dpropt.cpp:	// get a printer handle...
DFILE\dpropt.cpp:	if (!OpenPrinter( PrintType, &hPrint, NULL ))
DFILE\dpropt.cpp:	// get the size of the printer info block...
DFILE\dpropt.cpp:	ClosePrinter(hPrint);	// must close when done...
DFILE\dpropt.cpp:	//	psDlg.Flags = PSD_MARGINS | PSD_DISABLEPRINTER | PSD_INTHOUSANDTHSOFINCHES | PSD_SHOWHELP ;
DFILE\dpropt.cpp:	//	psDlg.Flags = PSD_MARGINS | PSD_DISABLEPRINTER | PSD_INHUNDREDTHSOFMILLIMETERS | PSD_SHOWHELP ;
DFILE\dpropt.cpp://	psDlg.Flags = PSD_MARGINS | PSD_DISABLEPRINTER | PSD_SHOWHELP ;
DFILE\dpropt.cpp: 	psDlg.Flags = PSD_MARGINS | PSD_DISABLEPRINTER | PSD_SHOWHELP | PSD_DEFAULTMINMARGINS | PSD_INTHOUSANDTHSOFINCHES;
DFILE\dprset.cpp:// askPrinter nows calls common print dlg code in wprint.cpp.
DFILE\dprset.cpp:// Fix problem with selecting printer with the same name but different ports.
DFILE\dprset.cpp:// Not an issue with NT which requires unique printer names.
DFILE\dprset.cpp:// No longer support "Options..." button on printer dialog
DFILE\dprset.cpp:// Allow printer selection even if no default printer
DFILE\dprset.cpp:#define PRINTERBYTES	PRTPARTS * 20	// 20 printers?
DFILE\dprset.cpp:#define PRINTERINFOSEPARATOR	30		// need a non-printing character
DFILE\dprset.cpp:	{ // printer info stored as "<printer name>PRINTERINFOSEPARATOR<port name>"...
DFILE\dprset.cpp:		if (pszPort = strchr(pszName, PRINTERINFOSEPARATOR))
DFILE\dprset.cpp:// free up temporary printer name storage...
DFILE\dprset.cpp:// build printer list box (active printers)
DFILE\dprset.cpp:BOOL CRrDoc::getPrinters(HWND hDlg)
DFILE\dprset.cpp:	int nIndex = 0, nPrinters = 0;
DFILE\dprset.cpp:	if (!(lpszPortList = globalAlloc(GHND, (DWORD)PRINTERBYTES)))
DFILE\dprset.cpp:	if (GetProfileString((LPSTR)"PrinterPorts", (LPSTR)NULL, (LPSTR)"", (LPSTR)lpszPortList, PRINTERBYTES))
DFILE\dprset.cpp:		{ // get the printers
DFILE\dprset.cpp:					{ // don't put "un-ported" printers in list
DFILE\dprset.cpp:						// get memory for "<printer name>PRINTERINFOSEPARATOR<port name>" plus trailing null...
DFILE\dprset.cpp:						{ // got memory, tuck away the printer/port name...
DFILE\dprset.cpp:								PRINTERINFOSEPARATOR, (LPSTR)lpszPort);
DFILE\dprset.cpp:							nIndex = nPrinters;
DFILE\dprset.cpp:						nPrinters++;
DFILE\dprset.cpp:void CRrDoc::showDefPrinter(HWND hDlg)
DFILE\dprset.cpp:	char szPrinter[200];
DFILE\dprset.cpp:	if (GetProfileString((LPSTR)"windows", (LPSTR)"device", (LPSTR)"", (LPSTR)szPrinter, 200))
DFILE\dprset.cpp:		if ((pszName = strtok(szPrinter, ",")) && (pszDriver = strtok(NULL, ",")) &&
DFILE\dprset.cpp:			wsprintf((LPSTR)szPrinter, (LPSTR)getString(IDS_0026, 0), (LPSTR)pszName,
DFILE\dprset.cpp:			SetDlgItemText(hDlg, DPSDEFAULT, szPrinter);
DFILE\dprset.cpp:int CRrDoc::printerSetup(HWND hDlg, LPSTR pName, LPSTR pDriver, LPSTR pPort)
DFILE\dprset.cpp:	{ // not a valid printer (?!)
DFILE\dprset.cpp:	// printer setup dialog with another Win32 method.  See Steve's mail.  scott
DFILE\dprset.cpp:			if (!pDoc->getPrinters(hDlg))
DFILE\dprset.cpp:				EndDialog(hDlg, 0);	  // no printers or no memory...
DFILE\dprset.cpp:			pDoc->showDefPrinter(hDlg);
DFILE\dprset.cpp:					pDoc->bFixFonts = (pDoc->printerSetup(hDlg, pName, pDriver, pPort) == IDOK);
DFILE\dprset.cpp:int CRrDoc::askPrinter()
DFILE\dexport.cpp:// New HTML export structure was integrated into printer driver.
DFILE\dexport.cpp:// No printer, no PDI export
DFILE\dprint.cpp:// The printer properties changed in the Printer Property Dialog now will be
DFILE\dprint.cpp:// Set Printer Edit control on focus to fix RRW 2990 and RSW 2385.
DFILE\dprint.cpp:// Also enable the Printer Property button temorARYLY for some testing.
DFILE\dprint.cpp:// DocumentProperties requires the printer name not be NULL.
DFILE\dprint.cpp:// Runtime changes, since runtime only uses this for selecting printer.
DFILE\dprint.cpp:// Save printer type, etc. before calling fontChange()
DFILE\dprint.cpp:// Fix printer query code for paper tray choices (WIN32)
DFILE\dprint.cpp:// Show printer net connection after selecting w/ Printers button
DFILE\dprint.cpp:// Always show printer at top of dialog (MS Office)
DFILE\dprint.cpp:// Add collate checkbox and display printer name in dest, not caption bar
DFILE\dprint.cpp:// Call MFC/Common dialog for printer setup (3.0)
DFILE\dprint.cpp:// Use our own paper tray names for lousy printer drivers RRW #1409, RSW #874
DFILE\dprint.cpp:#include <winspool.h>	// for Win32 printer stuff
DFILE\dprint.cpp:	m_pDoc->m_pReport->m_Util.errBox( 'D', m_pDoc->m_pReport->m_Util.getFString( IDS_PRT_INFO_ERR, 2) );		// "Error retrieving printer information"
DFILE\dprint.cpp:				// If the Printer Edit control is not on focus, no keyboard key
DFILE\dprint.cpp:				// The printer properties now accesable.  HXC 3/24/97
DFILE\dprint.cpp:				case 1139:		// printer combo box
DFILE\dprint.cpp:					{ // printer change
DFILE\dprint.cpp:	BOOL bPrinterChanged = FALSE;
DFILE\dprint.cpp:	BOOL bGotHdl = OpenPrinter( m_pDoc->PrintType, &hPrint, NULL );
DFILE\dprint.cpp:	// get a printer handle...
DFILE\dprint.cpp:	/*  TEMPORARY CHANGE BY CAS 5/1/2015 TO ATTEMPT TO ISOLATE PRINTER ISSUES WITH KYOCERA DRIVERS */
DFILE\dprint.cpp:	if (!OpenPrinter( m_pDoc->PrintType, &hPrint, NULL ) ||
DFILE\dprint.cpp:		// get the size of the printer info block...
DFILE\dprint.cpp:	ClosePrinter(hPrint);	// must close when done...
DFILE\dprint.cpp:			bPrinterChanged = TRUE;
DFILE\dprint.cpp:		// store the printer properties
DFILE\dprint.cpp:#if !defined(RUNDLL) // just store printer if rundll
DFILE\dprint.cpp:		if (bPrinterChanged ||
DFILE\dprint.cpp:		{ // printer or resolution change.  
DFILE\dprint.cpp:			m_pDoc->m_pReport->m_Util.errBox( 'D', m_pDoc->m_pReport->m_Util.getFString( IDS_COMMON_DLG_ERR, 2) );		// "Error retrieving printer information"
DFILE\htmldlg.cpp:// New HTML export structure was integrated into printer driver.
alive\rrlite\viewimg.cpp:// Output image to display or printer
alive\rrlite\viewimg.cpp:			// now scale to printer units
alive\rrlite\viewimg.cpp:// Scan PDI data & output page to screen or printer - maintain R&R code
alive\rrlite\rrvwctrl.cpp:	m_bGotPrinter = FALSE;				// default to no printer
alive\rrlite\rrvwctrl.cpp:	m_szPrtName[0] = '\0';				// no printer yet
alive\rrlite\rrvwctrl.cpp:	m_sizeUnprint.cy = HZRES / 4;		// (in case there's no default printer)
alive\rrlite\rrvwctrl.cpp:	// get default printer info
alive\rrlite\rrvwctrl.cpp:	m_bGotPrinter = getPrinterInfo();
alive\rrlite\rrvwctrl.cpp:	if ( !m_bGotPrinter ) // disable print button if no printer
alive\rrlite\rrvwctrl.cpp:			// uh oh, better check printer situation
alive\rrlite\rrvwctrl.cpp:			m_bGotPrinter = getPrinterInfo();
alive\rrlite\rrvwctrl.cpp:				IDC_PRINTREPORT, (LPARAM)MAKELONG( m_bGotPrinter, 0 ));
alive\rrlite\rrvwctrl.cpp:	if ( m_nPageCount && m_bGotPrinter && m_bReportLoaded &&
alive\rrlite\rrvwctrl.cpp:	{ // we got a printer and we got the report
alive\rrlite\viewbox.cpp:	{ // to printer
alive\rrlite\printrep.cpp:// Set printer resolution and unprintable values
alive\rrlite\printrep.cpp:void ViewCtrl::getPrinterMetrics( HDC hDC )
alive\rrlite\printrep.cpp:	// values in printer resolution
alive\rrlite\printrep.cpp:// Get default printer name and information context
alive\rrlite\printrep.cpp:BOOL ViewCtrl::getPrinterInfo( void )
alive\rrlite\printrep.cpp:	{ // we should have default printer info now
alive\rrlite\printrep.cpp:		{ // store the printer properties
alive\rrlite\printrep.cpp:			if ( !m_bGotPrinter && ( pDevNames != NULL ))
alive\rrlite\printrep.cpp:			{ // get printer name
alive\rrlite\printrep.cpp:				{ // get printer metrics
alive\rrlite\printrep.cpp:					getPrinterMetrics( pd.hDC );
alive\rrlite\printrep.cpp:			return ( pDevNames != NULL );	// got a default printer?
alive\rrlite\printrep.cpp:// Get printer info from common dialog, then print away
alive\rrlite\printrep.cpp:	// first get a printer handle
alive\rrlite\printrep.cpp:	if ( !OpenPrinter( m_szPrtName, &hPrint, NULL ) ||
alive\rrlite\printrep.cpp:		// get the size of the printer info block...
alive\rrlite\printrep.cpp:			ClosePrinter( hPrint );
alive\rrlite\printrep.cpp:	ClosePrinter( hPrint );
alive\rrlite\printrep.cpp:		{ // check for printer change
alive\rrlite\printrep.cpp:			{ // new printer name
alive\rrlite\printrep.cpp:			getPrinterMetrics( m_pd.hDC );
alive\rrlite\viewtext.cpp:	// scale points to printer or screen resolution
alive\rrlite\viewtext.cpp:// Scan PDI data & output page to screen or printer
alive\rrlite\viewlbox.cpp:// Output lines/boxes to display or printer - from PWINT.CPP
alive\rrlite\viewlbox.cpp:	// white hatch background at the printer
alive\rrlite\viewlbox.cpp:		// now scale to printer units
alive\rrlite\viewobj.cpp:		// now scale to printer units
alive\rrlite\viewrep.cpp:// Horizontal screen resolution -> horizontal printer resolution
alive\rrlite\viewrep.cpp:// Vertical screen resolution -> vertical printer resolution
alive\rrlite\viewrep.cpp:// Scale to display or printer
alive\rrlite\viewchrt.cpp:		// now scale to printer units
WMAIN\readsrt.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
WMAIN\rrinit.cpp:// Load printer driver DLL after calling wInit() so that wReset will work if
WMAIN\rrinit.cpp:// fixed bug where if we could not load the printer driver, we did not unload
WMAIN\rrinit.cpp:// the printer driver could not be loaded.
WMAIN\rrinit.cpp:	// for the printer driver DLL, if this fails make sure we unload the
WMAIN\rrinit.cpp:	if ((pDoc->hPrinterDriver = LoadAndCheckLibrary(m_elmFileManager.GetDefaultPrinterDriver(),
WMAIN\rrinit.cpp:		return FALSE;	  // no printer driver, no app
WMAIN\explmgr.cpp:// Printer drivers. 
WMAIN\explmgr.cpp:static char szDefaultPrinterName[] = "rrpd.dll"     ;
WMAIN\explmgr.cpp:CString CExplicitLibraryManager::GetDefaultPrinterDriver() const
WMAIN\explmgr.cpp:	CString csDefaultPrinterName = FindLocalDllFile ( szDefaultPrinterName ) ;
WMAIN\explmgr.cpp:	ASSERT( DoesDllExist(csDefaultPrinterName) );
WMAIN\explmgr.cpp:	return csDefaultPrinterName ;
WMAIN\cmdline.cpp:	pDoc->getPrinterDriver(TRUE); 	// get current printer
WMAIN\version.cpp:// When printer DLL is loaded, force update of its AccuSoft pointers if
WMAIN\version.cpp:	// if we just loaded the printer DLL, and the AccuSoft DLL is already
WMAIN\version.cpp:	// loaded, then re-init the printer DLL's AccuSoft routine pointers
WMAIN\version.cpp:	CString csPrinterDriver = m_elmFileManager.GetDefaultPrinterDriver() ;
WMAIN\version.cpp:	if ((!stricmp (lpszLibFileName, csPrinterDriver)) && (pDoc->hImageLib != NULL))
WMAIN\version.cpp:		pDoc->hPrinterDriver = hLoadedDLL;	// loadImageLib uses hPrinterDriver
WMAIN\winit.cpp:// Look closely at call to init PDF printer
WMAIN\winit.cpp:// Printer from INI file
WMAIN\winit.cpp:// Get PrevWinClr and DBMemoEd in Runtime; init printer and fonts in runtime.
WMAIN\winit.cpp:#include "_wprintu.h"   // for getPrinterDriver(), setPrevIndents(), DbfXStr
WMAIN\winit.cpp:// initPDFPrinterDriver()
WMAIN\winit.cpp:void CRrDoc::initPDFPrinterDriver()
WMAIN\winit.cpp:	hPDFPrinterDriver = NULL ;
WMAIN\winit.cpp:		hPDFPrinterDriver = LoadLibrary("CDINTF.DLL") ;
WMAIN\winit.cpp:		hPDFPrinterDriver = NULL ;
WMAIN\winit.cpp:	if (hPDFPrinterDriver == NULL)
WMAIN\winit.cpp:	pdfinit = (PDFINIT)GetProcAddress(hPDFPrinterDriver, "PDFDriverInit") ;
WMAIN\winit.cpp:	hPDFPrinter = (*pdfinit)(getString(IDS_2647,0)) ;
WMAIN\winit.cpp:	if (hPDFPrinter == NULL)
WMAIN\winit.cpp:		pdfinit = (PDFINIT)GetProcAddress(hPDFPrinterDriver, "DriverInit") ;
WMAIN\winit.cpp:		hPDFPrinter = (*pdfinit)(getString(IDS_2647,0)) ;
WMAIN\winit.cpp:		if (hPDFPrinter == NULL)
WMAIN\winit.cpp:			hPDFPrinterDriver = NULL ;
WMAIN\winit.cpp:	initPDFPrinterDriver() ;
WMAIN\winit.cpp:	GetPrivateProfileString(WxDefKey, WxDefPrinter, "", Defs.Printer, PATHLENGTH, theApp.m_elmFileManager.GetRRInitFile()) ;
WMAIN\winit.cpp:	getPrinterDriver(TRUE); 	// get current printer
WMAIN\winit.cpp://	initFonts();				// read in printer fonts
WUTIL\labels.cpp:/* Routine to choose a page size from first available in printer driver
WUTIL\wglobal.cpp:// Check page size count returned from printer driver
WUTIL\wstring.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
WUTIL\wstring.cpp:// used in export dialog in runtime (ri_printer = '?')
WUTIL\futil.cpp:		lpfnDotWidth = (LPFNPWDOTWIDTH)GetProcAddress(hPrinterDriver, MAKEINTRESOURCE(PWDOTWIDTH));
WUTIL\futil.cpp:		lpfnCharWidth = (LPFNPWCHARWIDTH)GetProcAddress(hPrinterDriver, MAKEINTRESOURCE(PWCHARWIDTH));
WUTIL\futil.cpp:		{ // got a printer?
WPRINTUI\pstatdlg.cpp:		if (!fieldfit( DPRPRINTER, filename ))
WPRINTUI\pstatdlg.cpp://	SMH		SetDlgItemText(hDlg,DPRPRINTER,(LPSTR)getString(IDS_0063,0));
WPRINTUI\pstatdlg.cpp:		SetDlgItemText( DPRPRINTER, filename );
WPRINTUI\pstatdlg.cpp:		SetDlgItemText( DPRPRINTER, szTemp );
WPRINTUI\pstatdlg.cpp:void CRrDoc::dspRecCnt(BOOL bDoit)	// show record count in printer dialog
WPRINTUI\wprev.cpp:// Need to adjust min window calculation for printers w/ differing horizontal
WPRINTUI\wprev.cpp:// Pass update region to paint routine in printer driver
WPRINTUI\wprev.cpp:	LPFNPWRESET lpfnReset = (LPFNPWRESET)GetProcAddress(hPrinterDriver,
WPRINTUI\wprev.cpp:	}	 // no printers!
WPRINTUI\wprev.cpp:	if (!fldsOnNewPage(TRUE) && ((RepType != REPNORM) || printCheck()) && initPrinter(TRUE))
WPRINTUI\wprev.cpp:	{ // printer initialized, now create the window
WPRINTUI\wexport.cpp:// Check for printer if PDI export
WPRINTUI\wexport.cpp:// Fixed bug that if ri_outfile was bad and ri_printer=A we now catch that early
WPRINTUI\wexport.cpp:		// for PDI export, call initPrinter here rather than in txtx_expInitPrt
WPRINTUI\wexport.cpp:		// p/c initPrinter calls pwInit, which must have a handle to the already
WPRINTUI\wexport.cpp:		if ( !m_pDoc->initPrinter( FALSE ))	// PDI export needs printer driver
WPRINTUI\wexport.cpp:	//	in RI_PRINTER & user then chooses Export.
WPRINTUI\wexport.cpp:		{ // got a printer or RI_PRINTER == 'V'
WPRINTUI\wexport.cpp:		{ // no printer configured
WPRINTUI\wexport.cpp:			FreeLibrary(m_pDoc->hPrinterDriver);	// free old
WPRINTUI\wexport.cpp:			m_pDoc->hPrinterDriver = hTemp; 	// set to new one
WPRINTUI\wexport.cpp:				m_pDoc->Printing = ((lpfnCreate = (LPFNDBXCREATE)GetProcAddress(m_pDoc->hPrinterDriver,
WPRINTUI\wexport.cpp:		 					   (lpfnStore = (LPFNDBXSTORE)GetProcAddress(m_pDoc->hPrinterDriver,
WPRINTUI\wexport.cpp:				if (lpfnInit = (LPFNPWINIT)GetProcAddress(m_pDoc->hPrinterDriver,MAKEINTRESOURCE((WORD)PWINIT)))
WPRINTUI\wexport.cpp:			if (lpfnReset = (LPFNPWRESET)GetProcAddress(m_pDoc->hPrinterDriver,MAKEINTRESOURCE(PWRESET)))
WPRINTUI\wexport.cpp:				if (lpfnClose = (LPFNDBXCLOSE)GetProcAddress(m_pDoc->hPrinterDriver,MAKEINTRESOURCE((WORD)DBXCLOSE)))
WPRINTUI\wexport.cpp:		FreeLibrary(m_pDoc->hPrinterDriver);
WPRINTUI\wexport.cpp:	// restore main printer driver library
WPRINTUI\wexport.cpp:		m_pDoc->hPrinterDriver = theApp.LoadAndCheckLibrary (
WPRINTUI\wexport.cpp:						theApp.m_elmFileManager.GetDefaultPrinterDriver(),
WPRINTUI\wexport.cpp:			FreeLibrary(m_pDoc->hPrinterDriver);	// free old
WPRINTUI\wexport.cpp:			m_pDoc->hPrinterDriver = hTemp; 	// set to new one
WPRINTUI\wexport.cpp:			m_pDoc->Printing = ((lpfnCreate = (LPFNDBXCREATE)GetProcAddress(m_pDoc->hPrinterDriver,
WPRINTUI\wexport.cpp:		 				   (lpfnStore = (LPFNDBXSTORE)GetProcAddress(m_pDoc->hPrinterDriver,
WPRINTUI\wexport.cpp:			if (lpfnClose = (LPFNDBXCLOSE)GetProcAddress(m_pDoc->hPrinterDriver,MAKEINTRESOURCE((WORD)DBXCLOSE)))
WPRINTUI\wexport.cpp:		FreeLibrary(m_pDoc->hPrinterDriver);
WPRINTUI\wexport.cpp:		// restore main printer driver library
WPRINTUI\wexport.cpp:		m_pDoc->hPrinterDriver = theApp.LoadAndCheckLibrary (
WPRINTUI\wexport.cpp:						theApp.m_elmFileManager.GetDefaultPrinterDriver(),
WPRINTUI\wexport.cpp:			FreeLibrary(m_pDoc->hPrinterDriver);	// free old
WPRINTUI\wexport.cpp:			m_pDoc->hPrinterDriver = hTemp; 	// set to new one
WPRINTUI\wexport.cpp:				m_pDoc->Printing = ((lpfnCreate = (LPFNDBXCREATE)GetProcAddress(m_pDoc->hPrinterDriver,
WPRINTUI\wexport.cpp:										(lpfnStore = (LPFNDBXSTORE)GetProcAddress(m_pDoc->hPrinterDriver,
WPRINTUI\wexport.cpp:				if (lpfnInit = (LPFNPWINIT)GetProcAddress(m_pDoc->hPrinterDriver,MAKEINTRESOURCE((WORD)PWINIT)))
WPRINTUI\wexport.cpp:									if (lpfnReset = (LPFNPWRESET)GetProcAddress(m_pDoc->hPrinterDriver,MAKEINTRESOURCE(PWRESET)))
WPRINTUI\wexport.cpp:									if (lpfnInit = (LPFNPWINIT)GetProcAddress(m_pDoc->hPrinterDriver,MAKEINTRESOURCE((WORD)PWINIT)))
WPRINTUI\wexport.cpp:			if (lpfnReset = (LPFNPWRESET)GetProcAddress(m_pDoc->hPrinterDriver,MAKEINTRESOURCE(PWRESET)))
WPRINTUI\wexport.cpp:				if (lpfnClose = (LPFNDBXCLOSE)GetProcAddress(m_pDoc->hPrinterDriver,MAKEINTRESOURCE((WORD)DBXCLOSE)))
WPRINTUI\wexport.cpp:		FreeLibrary(m_pDoc->hPrinterDriver);
WPRINTUI\wexport.cpp:		// restore main printer driver library
WPRINTUI\wexport.cpp:		m_pDoc->hPrinterDriver = theApp.LoadAndCheckLibrary (theApp.m_elmFileManager.GetDefaultPrinterDriver(),
WPRINTUI\wprint.cpp:// Printer from INI
WPRINTUI\wprint.cpp:// getDevMode now will return either Default Printer proerties, or
WPRINTUI\wprint.cpp:// getDevMode uses PDevMode to inialize the printer. Fix printer property
WPRINTUI\wprint.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
WPRINTUI\wprint.cpp:// Changes for PDI export w/o printer
WPRINTUI\wprint.cpp:// DocumentProperties requires the printer name not be NULL.
WPRINTUI\wprint.cpp:// Check copyused() before send non-collate job to printer
WPRINTUI\wprint.cpp:// Change to simple open printer (PrintType) in checkPrtChange() instead of
WPRINTUI\wprint.cpp:// enumerating printers, which doesn't seem to work in RRW or in sample
WPRINTUI\wprint.cpp:// program on CD.  Printer enumeration also presents NT issues.
WPRINTUI\wprint.cpp:// Check for collate flag and set copy count and printer accordingly
WPRINTUI\wprint.cpp:// Allow use of getPrinterDriver() by runtime DLL.
WPRINTUI\wprint.cpp:// Do GetPrivateProfile strings in initPrinter that were being done in
WPRINTUI\wprint.cpp:// conditional code in printer driver DLL.  This is to make a common DLL.
WPRINTUI\wprint.cpp:// Text align and background set now done after StartPage in printer driver DLL
WPRINTUI\wprint.cpp:// PrintCopies returns.  Set Collate to default (now Yes) on printer change
WPRINTUI\wprint.cpp:// Move StartDoc() call from printReport() to initPrinter()
WPRINTUI\wprint.cpp:// Move stuff into initPrinter() from pd\pwdriver pwInit() function
WPRINTUI\wprint.cpp:// New WIN32 support for getting printer info
WPRINTUI\wprint.cpp:// In checkPrtChange(), check for matching driver name and use default printer
WPRINTUI\wprint.cpp:// printer.  This was R?W 2.0 bug too.
WPRINTUI\wprint.cpp:// No more pitchFont in printer structure
WPRINTUI\wprint.cpp:// Remove getPrinterDriver for MFC version (3.0)
WPRINTUI\wprint.cpp:#include <winspool.h>	// for Win32 printer stuff
WPRINTUI\wprint.cpp:BOOL CRrDoc::getPrinterDriver( BOOL bClear )		// retrieve printer from win.ini
WPRINTUI\wprint.cpp:	// get printer info the MFC way...
WPRINTUI\wprint.cpp:// from a printer name using new WIN32 API calls.  This routine is called
WPRINTUI\wprint.cpp:// other information about a printer such as paper size and tray.
WPRINTUI\wprint.cpp:// Call this routine with a printer name.  DEVMODE size is retrieved and
WPRINTUI\wprint.cpp:// Pointer to DEVMODE (and more) or NULL if printer driver calls fail or
WPRINTUI\wprint.cpp:LPDEVMODE getDevMode(LPTSTR pPrinterName)
WPRINTUI\wprint.cpp:	// get a printer handle...
WPRINTUI\wprint.cpp:	if (!OpenPrinter( pPrinterName, &hPrint, NULL ))
WPRINTUI\wprint.cpp:	// get the size of the printer info block...
WPRINTUI\wprint.cpp:	if ((lPrintInfo = DocumentProperties( NULL, hPrint, pPrinterName, NULL, NULL, 0 )) <= 0 )
WPRINTUI\wprint.cpp:		if ( DocumentProperties( NULL, hPrint, pPrinterName, pTemp, pDoc->PDevMode,
WPRINTUI\wprint.cpp:		if ( DocumentProperties( NULL, hPrint, pPrinterName, pTemp, NULL,
WPRINTUI\wprint.cpp:	ClosePrinter( hPrint );	// must close when done...
WPRINTUI\wprint.cpp:// return default printer tray for current printer
WPRINTUI\wprint.cpp:// set up DEVMODE and obtain the printer device context
WPRINTUI\wprint.cpp:BOOL CRrDoc::initPrinter(BOOL bPreview)
WPRINTUI\wprint.cpp:	if ( hPrinterDriver == NULL )
WPRINTUI\wprint.cpp:		errorMessage ( getString(IDS_0624, 0), theApp.m_elmFileManager.GetDefaultPrinterDriver() ) ;
WPRINTUI\wprint.cpp:	{ // no printer or can't get info
WPRINTUI\wprint.cpp:		{ // can't print w/o printer/DEVMODE, or no export w/o typefaces
WPRINTUI\wprint.cpp:		{ // let printer whack out uncollated copies
WPRINTUI\wprint.cpp:	{ // cannot create a printer device context...
WPRINTUI\wprint.cpp:	{ // got printer and got DC
WPRINTUI\wprint.cpp:		PrtStruct->pDest.wpd.printerInchX = PrinterInchX;
WPRINTUI\wprint.cpp:		PrtStruct->pDest.wpd.printerInchY = PrinterInchY;
WPRINTUI\wprint.cpp:			VTRES, PrtStruct->pDest.wpd.printerInchY );
WPRINTUI\wprint.cpp:			PrtStruct->pDest.wpd.pOffset.y, VTRES, PrtStruct->pDest.wpd.printerInchY );
WPRINTUI\wprint.cpp:		PrtStruct->pDest.wpd.leftMar = MulDiv( leftMar, PrtStruct->pDest.wpd.printerInchX, 100 );
WPRINTUI\wprint.cpp:	{ // set up for export w/o printer
WPRINTUI\wprint.cpp:		PrtStruct->pDest.wpd.printerInchX = HZRES;
WPRINTUI\wprint.cpp:		PrtStruct->pDest.wpd.printerInchY = VTRES;
WPRINTUI\wprint.cpp:		PrinterInchX = HZRES;
WPRINTUI\wprint.cpp:		PrinterInchY = VTRES;
WPRINTUI\wprint.cpp:	//// pull these out of the printer driver DLL so it can be common ////
WPRINTUI\wprint.cpp:	LPFNPWINIT lpfnInit = (LPFNPWINIT)GetProcAddress( hPrinterDriver, MAKEINTRESOURCE( PWINIT ));
WPRINTUI\wprint.cpp:		// install hDIB for palette to printer driver
WPRINTUI\wprint.cpp:	LPFNPWRESET lpfnReset = (LPFNPWRESET)GetProcAddress(hPrinterDriver, MAKEINTRESOURCE(PWRESET));
WPRINTUI\wprint.cpp:	}	 // no printers!
WPRINTUI\wprint.cpp:	// 2. Initialize printer structure, create device context, StartDoc.
WPRINTUI\wprint.cpp:	if ((sorted = printCommon()) && initPrinter( FALSE ) && !PrState)
WPRINTUI\wprint.cpp:			// delete printer device context...
WPRINTUI\wprint.cpp:// check for printer changes...
WPRINTUI\wprint.cpp:	// if printer from .ini
WPRINTUI\wprint.cpp:	if (Defs.Printer[0])
WPRINTUI\wprint.cpp:		if (stricmp(Defs.Printer, "default") == 0)
WPRINTUI\wprint.cpp:			// user always wants default printer
WPRINTUI\wprint.cpp:			getPrinterDriver(TRUE) ;
WPRINTUI\wprint.cpp:			// user wants specic printer - if it exists, use it
WPRINTUI\wprint.cpp:			if (OpenPrinter(Defs.Printer, &hPrint, NULL))
WPRINTUI\wprint.cpp:				strcpy(PrintType, Defs.Printer) ;
WPRINTUI\wprint.cpp:				ClosePrinter( hPrint );
WPRINTUI\wprint.cpp:				Defs.Printer[0] = '\0' ;
WPRINTUI\wprint.cpp:	if ( !PrintType[0] || !OpenPrinter( PrintType, &hPrint, NULL ))
WPRINTUI\wprint.cpp:		getPrinterDriver( TRUE ); 	// back to default, if any
WPRINTUI\wprint.cpp:		BOOL bClose = ClosePrinter( hPrint );
WPRINTUI\pvpgdlg.cpp:	{ // caption to printer type/port if there...
WPRINTUI\prevdraw.cpp:// scale printer horizontal dimensions to screen dimensions
WPRINTUI\prevdraw.cpp:		if (lpfnPlayBackPage  = (LPFNPWPLAYBACKPAGE)GetProcAddress(m_pDoc->hPrinterDriver,
WPRINTUI\prevdraw.cpp:		pSizeX = (m_pDoc->PrinterInchX == m_pDoc->PrinterInchY) ?
WPRINTUI\prevdraw.cpp:			MulDiv( m_pDoc->PrtStruct->pDest.wpd.pSize.x, m_pDoc->PrinterInchY, m_pDoc->PrinterInchX );
WPRINTUI\prevdraw.cpp:	pSizeX = (m_pDoc->PrinterInchX == m_pDoc->PrinterInchY) ? m_pDoc->PrtStruct->pDest.wpd.pSize.x :
WPRINTUI\prevdraw.cpp:		MulDiv(m_pDoc->PrtStruct->pDest.wpd.pSize.x, m_pDoc->PrinterInchY, m_pDoc->PrinterInchX);
WPRINTUI\prevdraw.cpp:	if (lpfnClearFonts = (LPFNPWCLEARFONTCACHE)GetProcAddress(m_pDoc->hPrinterDriver,
WPRINTUI\prevdraw.cpp:		// compensate for different horizontal/vertical printer resolution?
WPRINTUI\prevdraw.cpp:		pSizeX = (m_pDoc->PrtStruct->pDest.wpd.printerInchX == m_pDoc->PrtStruct->pDest.wpd.printerInchY) ?
WPRINTUI\prevdraw.cpp:			MulDiv(m_pDoc->PrtStruct->pDest.wpd.pSize.x, m_pDoc->PrtStruct->pDest.wpd.printerInchY,
WPRINTUI\prevdraw.cpp:			m_pDoc->PrtStruct->pDest.wpd.printerInchX);
WPRINTUI\prevdraw.cpp:	if (lpfnPlayBackPage  = (LPFNPWPLAYBACKPAGE)GetProcAddress(m_pDoc->hPrinterDriver,
WPRINTUI\prevdraw.cpp:	LPFNPWRESETDRIVER lpfnResetDriver = (LPFNPWRESETDRIVER)GetProcAddress(m_pDoc->hPrinterDriver,
WPRINTUI\prevdraw.cpp:	LPFNPWNEXTPREVPAGE lpfnNextPrevPage = (LPFNPWNEXTPREVPAGE)GetProcAddress(m_pDoc->hPrinterDriver,
WPRINTUI\wtxtexp.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
WPRINTUI\wtxtexp.cpp:// Also no longer require a printer.
WPRINTUI\wtxtexp.cpp:// Change initPrinter arg to TRUE (indicates we're not previewing).
WPRINTUI\wtxtexp.cpp:extern LPDEVMODE getDevMode(LPTSTR pPrinterName);
WPRINTUI\wtxtexp.cpp:	{ // Other printer structure stuff
WPRINTUI\wtxtexp.cpp:		REXPPS.pStat = FALSE;			// not ready to init printer yet...
WPRINTUI\wtxtexp.cpp:		// Don't call initPrinter any more since wpd struct is no longer embedded in rtf struct
WPRINTUI\wtxtexp.cpp:		//pDoc->initPrinter(TRUE); 	// set up printer structure
WPRINTUI\wtxtexp.cpp:		// beginning of stuff copied (then customized) from initPrinter()
WPRINTUI\wtxtexp.cpp:		if ( pDoc->hPrinterDriver == NULL )
WPRINTUI\wtxtexp.cpp:			pDoc->errorMessage ( getString(IDS_0624, 0), theApp.m_elmFileManager.GetDefaultPrinterDriver() ) ;
WPRINTUI\wtxtexp.cpp:		{ // no printer or can't get info
WPRINTUI\wtxtexp.cpp:			{ // can't print w/o printer/DEVMODE, or no export w/o typefaces
WPRINTUI\wtxtexp.cpp:			{ // let printer whack out uncollated copies
WPRINTUI\wtxtexp.cpp:		{ // got printer and got DC
WPRINTUI\wtxtexp.cpp:			REXPPS.printerInchX = pDoc->PrinterInchX;
WPRINTUI\wtxtexp.cpp:			REXPPS.printerInchY = pDoc->PrinterInchY;
WPRINTUI\wtxtexp.cpp:				VTRES, REXPPS.printerInchY );
WPRINTUI\wtxtexp.cpp:				REXPPS.pOffset.y, VTRES, REXPPS.printerInchY );
WPRINTUI\wtxtexp.cpp:			REXPPS.leftMar = MulDiv( leftMar, REXPPS.printerInchX, 100 );
WPRINTUI\wtxtexp.cpp:		{ // set up for export w/o printer
WPRINTUI\wtxtexp.cpp:			REXPPS.printerInchX = HZRES;
WPRINTUI\wtxtexp.cpp:			REXPPS.printerInchY = VTRES;
WPRINTUI\wtxtexp.cpp:			pDoc->PrinterInchX = HZRES;
WPRINTUI\wtxtexp.cpp:			pDoc->PrinterInchY = VTRES;
WPRINTUI\wtxtexp.cpp:		LPFNPWINIT lpfnInit = (LPFNPWINIT)GetProcAddress( pDoc->hPrinterDriver, MAKEINTRESOURCE( PWINIT ));
WPRINTUI\wtxtexp.cpp:	// end of stuff copied (then customized) from initPrinter()
WPRINTUI\wtxtexp.cpp:		HEXPPS.pStat = FALSE;			// not ready to init printer yet...
WPRINTUI\wtxtexp.cpp:		HEXPPS.printerInchX = pDoc->PrinterInchX;	// for printer driver
WPRINTUI\wtxtexp.cpp:		HEXPPS.printerInchY = pDoc->PrinterInchY;
WPRINTUI\wtxtexp.cpp:		//	pDoc->initPrinter(TRUE); 	// set up printer structure
WPRINTUI\wtxtexp.cpp:	// file created, now create printer DC, etc. & call pwInit() to write header info
WPRINTUI\wtxtexp.cpp://		if ( !pDoc->initPrinter( FALSE ))	// PDI export needs printer driver
WPRINTUI\wtxtexp.cpp:	// pwInit called from initPrinter() (in createExportFile) in PDI _ EXPORT
DMISC\druntime.cpp:// Database export: added "Export" to dialog that comes up when RI_PRINTER=?
DMISC\druntime.cpp:#define ID_PRINTER 102
DMISC\druntime.cpp:				case ID_PRINTER:
DMISC\druntime.cpp:					::CheckRadioButton(hDlg,ID_SCREEN,ID_EXPORT,ID_PRINTER);
PD-ORIG\wexpint.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
PD-ORIG\wexpint.cpp:/*	This routine corresponds to the wpd routine screenToPrinterX (in pwint.c)
PD-ORIG\wexpint.cpp:// output a line to display or printer
PD-ORIG\memdlg.cpp:// the support to print the ole object records inside the printer driver.
PD-ORIG\memdlg.cpp:// Converted the printer driver to an MFC Extension DLL.
PD-ORIG\memdlg.cpp:// Printer driver modules are about to be ported to MFC.
PD-ORIG\memdlg.cpp:#include "product.h"  // Special version just for printer driver. 
PD-ORIG\rtfxint.cpp:	int pSize = MulDiv(WEXPPS.pSize.x,1440,WEXPPS.printerInchX);
PD-ORIG\rtfxint.cpp:	int pHeight =	MulDiv(WEXPPS.pSize.y,1440,WEXPPS.printerInchY);
PD-ORIG\rtfxint.cpp:		MulDiv(REXPPS.leftMarg,1440,WEXPPS.printerInchX),
PD-ORIG\rtfxint.cpp:		MulDiv(REXPPS.topMarg,1440,WEXPPS.printerInchY),
PD-ORIG\rtfxint.cpp:		MulDiv ( REXPPS.topMarg, 1440, WEXPPS.printerInchY));
PD-ORIG\rtfxint.cpp://	This routine corresponds to the wpd routine screenToPrinterX (in pwint.c)
PD-ORIG\rtfxint.cpp:// convert points to vertical printer resolution
PD-ORIG\rtfxint.cpp:	return MulDiv(pts, WEXPPS.printerInchY, POINTSIZE * 10);
PD-ORIG\rtfxint.cpp:				{ // check resources for printer
PD-ORIG\pwdriver.cpp:// Windows File Print printer driver routines
PD-ORIG\pwdriver.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
PD-ORIG\pwdriver.cpp:// the support to print the ole object records inside the printer driver.
PD-ORIG\pwdriver.cpp:// the printer driver.
PD-ORIG\pwdriver.cpp:// Converted the printer driver to an MFC Extension DLL.
PD-ORIG\pwdriver.cpp:// Printer driver modules are about to be ported to MFC.
PD-ORIG\pwdriver.cpp:// Move guts of pwInit() to wprintui\wprint.cpp (initPrinter())
PD-ORIG\pwdriver.cpp:#include "product.h"  // Special version just for printer driver. 
PD-ORIG\pwdriver.cpp:// return width of character based on printer font
PD-ORIG\pwdriver.cpp:// convert inches to printer resolution (e.g. dots)
PD-ORIG\pwdriver.cpp:	return ((DWORD)MulDiv(ps->pDest.wpd.printerInchX, inches, 100));
PD-ORIG\pwdriver.cpp:			VTRES, ps->pDest.wpd.printerInchY));
PD-ORIG\pwdriver.cpp:	var = !lineAscent ? VTRES/6 : (!leading ? lineAscent : MulDiv(lineAscent, VTRES, ps->pDest.wpd.printerInchY));
PD-ORIG\pwdriver.cpp:	return (MAKELONG(var,MulDiv(lineDescent, VTRES, ps->pDest.wpd.printerInchY)));
PD-ORIG\pwdriver.cpp:// feed the paper to TOF (printer only)
PD-ORIG\pwdriver.cpp:	{ // to printer only!
PD-ORIG\pwdriver.cpp:		BOOL bDeleteDC = DeleteDC(ps->pDest.wpd.printDC);	  // remove printer context
PD-ORIG\pxdriver.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
PD-ORIG\pxdriver.cpp:// zero and no default printer.
PD-ORIG\pxdriver.cpp:// Changes to support export w/o printer
PD-ORIG\pxdriver.cpp:	{ // use printer values
PD-ORIG\pxdriver.cpp:		fHdr.wPaperWidth = MulDiv( ps->pDest.wpd.pSize.x, HZRES, ps->pDest.wpd.printerInchX );
PD-ORIG\pxdriver.cpp:		fHdr.wPaperHeight = MulDiv( ps->pDest.wpd.pSize.y, HZRES, ps->pDest.wpd.printerInchY );
PD-ORIG\pxdriver.cpp:	{ // guess there's no printer available
PD-ORIG\pxdriver.cpp:	// prepare for no printer/device context
PD-ORIG\pxdriver.cpp:// Feed the paper to TOF (printer only)
PD-ORIG\pxdriver.cpp:	{ // printer only for PDI export
PD-ORIG\pxdriver.cpp:	{ // remove printer context
PD-ORIG\pxdriver.cpp:// Return width of character based on printer font
PD-ORIG\pxdriver.cpp:	// compute monospace width if no printer available
PD-ORIG\pxdriver.cpp:	return ( ps->pDest.wpd.printerInchX / nCharsInch );
PD-ORIG\pxdriver.cpp:// Convert inches to printer resolution (e.g. dots)
PD-ORIG\pxdriver.cpp:	return (DWORD)MulDiv( ps->pDest.wpd.printerInchX, wInches, 100 );
PD-ORIG\pxdriver.cpp:			VTRES, ps->pDest.wpd.printerInchY );
PD-ORIG\pxdriver.cpp:	{ // no leading or no printer
PD-ORIG\pxdriver.cpp:							{ // no leading or no printer
PD-ORIG\pxdriver.cpp:								{ // got a printer
PD-ORIG\pxdriver.cpp:								{ // no printer, wing it
PD-ORIG\pxdriver.cpp:		MulDiv( nLineAscent, VTRES, ps->pDest.wpd.printerInchY ));
PD-ORIG\pxdriver.cpp:	return MAKELONG( nValue, MulDiv( nLineDescent, VTRES, ps->pDest.wpd.printerInchY ));
PD-ORIG\rtfexp.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
PD-ORIG\rtfexp.cpp:// RRW 2968/RSW 2366: don't call CreateDC in RTF export if a printer
PD-ORIG\rtfexp.cpp:// R?W Bug 2636: compensate for Windows printer orientation.
PD-ORIG\rtfexp.cpp:// Adjust for change in expected return of printer init.
PD-ORIG\rtfexp.cpp:	{ // compensate if the Windows printer orientation is landscape
PD-ORIG\rtfexp.cpp:			VTRES, WEXPPS.printerInchX);
PD-ORIG\rtfexp.cpp:			VTRES, WEXPPS.printerInchY);
PD-ORIG\rtfexp.cpp:	// get left margin in printer resolution units
PD-ORIG\rtfexp.cpp:	WEXPPS.leftMar = MulDiv(pi->leftmar, WEXPPS.printerInchX, 100);
PD-ORIG\rtfexp.cpp:	WEXPPS.unTop = (WORD)MulDiv(WEXPPS.pOffset.y, VTRES, WEXPPS.printerInchY);
PD-ORIG\rtfexp.cpp:	// convert to printer resolution units
PD-ORIG\rtfexp.cpp:	REXPPS.topMarg = MulDiv(REXPPS.topMarg, WEXPPS.printerInchY, 100);
PD-ORIG\rtfexp.cpp:// return width of character based on printer font
PD-ORIG\rtfexp.cpp:// convert inches to printer resolution (e.g. dots)
PD-ORIG\rtfexp.cpp:	return ((DWORD)MulDiv(WEXPPS.printerInchX, inches, 100));
PD-ORIG\rtfexp.cpp:									VTRES, WEXPPS.printerInchY));
PD-ORIG\rtfexp.cpp:												MulDiv(lineAscent, VTRES, WEXPPS.printerInchY));
PD-ORIG\rtfexp.cpp:	return (MAKELONG(var, MulDiv(lineDescent, VTRES, WEXPPS.printerInchY)));
PD-ORIG\rtfexp.cpp:		DeleteDC(WEXPPS.printDC);	  // remove printer context
PD-ORIG\htmlint.cpp:// Also no longer require a printer.
PD-ORIG\htmlint.cpp://	This routine corresponds to the wpd routine screenToPrinterX (in pwint.c)
PD-ORIG\htmlint.cpp:// convert points to vertical printer resolution
PD-ORIG\htmlint.cpp:	return MulDiv(pts, HEXPPS.printerInchY, POINTSIZE * 10);
PD-ORIG\htmlint.cpp:		// May not have a printer, and therefore no printDC
PD-ORIG\htmlint.cpp:				{ // check resources for printer
PD-ORIG\wexpdriv.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
PD-ORIG\wexpdriv.cpp:// return width of character in device units based on printer font
PD-ORIG\wexpdriv.cpp:// stubbed wpd\PWPREV.C Windows File Preview printer driver routines
PD-ORIG\pwint.cpp:// Windows Print & Preview printer driver internal routines
PD-ORIG\pwint.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
PD-ORIG\pwint.cpp:// Use bFastPrint flag in printer structure, which is now set in EXE.  All this
PD-ORIG\pwint.cpp:// Fixed problem with printing to printer.  The wrong DC was being used.
PD-ORIG\pwint.cpp:// the support to print the ole object records inside the printer driver.
PD-ORIG\pwint.cpp:// the printer driver.
PD-ORIG\pwint.cpp:// Converted the printer driver to an MFC Extension DLL.
PD-ORIG\pwint.cpp:// Printer driver modules are about to be ported to MFC.
PD-ORIG\pwint.cpp:// Look for new overprint control (from INI file, for Generic printer)
PD-ORIG\pwint.cpp:// Use saved rgb values for screen or printer for boxed.
PD-ORIG\pwint.cpp:#include "product.h"  // Special version just for printer driver. 
PD-ORIG\pwint.cpp:// convert points to vertical printer resolution
PD-ORIG\pwint.cpp:	return (UINT)MulDiv(pts, ps->pDest.wpd.printerInchY, POINTSIZE * 10);
PD-ORIG\pwint.cpp:// scale printer horizontal dimensions to screen dimensions
PD-ORIG\pwint.cpp:// scale printer vertical dimensions to screen dimensions
PD-ORIG\pwint.cpp:// horizontal screen resolution -> horizontal printer resolution
PD-ORIG\pwint.cpp:UINT screenToPrinterX(LPPRT_STRUCT ps, UINT x)
PD-ORIG\pwint.cpp:	return ((UINT)MulDiv(ps->pDest.wpd.printerInchX, x, ps->pDest.wpd.inchX));
PD-ORIG\pwint.cpp:// vertical screen resolution -> vertical printer resolution
PD-ORIG\pwint.cpp:UINT screenToPrinterY(LPPRT_STRUCT ps, UINT y)
PD-ORIG\pwint.cpp:	return ((UINT)MulDiv(ps->pDest.wpd.printerInchY, y, ps->pDest.wpd.inchY));
PD-ORIG\pwint.cpp:// horizontal screen resolution -> horizontal printer graphics resolution
PD-ORIG\pwint.cpp:		ps->pDest.wpd.graphicsInchX = ps->pDest.wpd.printerInchX;
PD-ORIG\pwint.cpp:	scale = (double)ps->pDest.wpd.printerInchX / ps->pDest.wpd.graphicsInchX;
PD-ORIG\pwint.cpp:	return (screenToPrinterX(ps, x) / scale);
PD-ORIG\pwint.cpp:// vertical screen resolution -> vertical printer graphics resolution
PD-ORIG\pwint.cpp:		ps->pDest.wpd.graphicsInchY = ps->pDest.wpd.printerInchY;
PD-ORIG\pwint.cpp:	scale = ps->pDest.wpd.printerInchY / ps->pDest.wpd.graphicsInchY;
PD-ORIG\pwint.cpp:	return (screenToPrinterY(ps,y) / scale);
PD-ORIG\pwint.cpp:// output a line of text to display or printer  
PD-ORIG\pwint.cpp:						var = screenToPrinterX(ps, var);
PD-ORIG\pwint.cpp:						ydelta = screenToPrinterY(ps, var);
PD-ORIG\pwint.cpp:						pget2(ps, &var);	// get width in printer dots
PD-ORIG\pwint.cpp:						var = screenToPrinterX(ps, var);
PD-ORIG\pwint.cpp:				yLoc = MulDiv(ps->pDest.wpd.yPos, ps->pDest.wpd.printerInchY, VTRES);
PD-ORIG\pwint.cpp:// output images to display or printer
PD-ORIG\pwint.cpp:	int imgX    = screenToPrinterX ( ps, pImg->x    ) ;
PD-ORIG\pwint.cpp:	int imgWid  = screenToPrinterX ( ps, pImg->wid  ) ;
PD-ORIG\pwint.cpp:	int imgHite = screenToPrinterY ( ps, pImg->hite ) ;
PD-ORIG\pwint.cpp:	// This version lets printer driver do scaling, dithering, etc.
PD-ORIG\pwint.cpp:// output charts to display or printer
PD-ORIG\pwint.cpp:	int chartX    = screenToPrinterX ( ps, pChart->x) ;
PD-ORIG\pwint.cpp:	int chartWid  = screenToPrinterX ( ps, pChart->wWidth) ;
PD-ORIG\pwint.cpp:	int chartHite = screenToPrinterY ( ps, pChart->wHeight) ;
PD-ORIG\pwint.cpp:	// send to printer
PD-ORIG\pwint.cpp:// output images to display or printer
PD-ORIG\pwint.cpp:	int imgX    = screenToPrinterX ( ps, pObj->x       ) ;
PD-ORIG\pwint.cpp:	int imgWid  = screenToPrinterX ( ps, pObj->wWidth  ) ;
PD-ORIG\pwint.cpp:	int imgHite = screenToPrinterY ( ps, pObj->wHeight ) ;
PD-ORIG\pwint.cpp:// output boxes to display or printer
PD-ORIG\pwint.cpp:	// mjs 9/12/94  Use screen or printer colors.
PD-ORIG\pwint.cpp:	hatchBack = 0x00ffffff; // White hatch background at the printer.
PD-ORIG\dll.cpp:// the support to print the ole object records inside the printer driver.
PD-ORIG\dll.cpp:// Converted the printer driver to an MFC Extension DLL.
PD-ORIG\dll.cpp:// Printer driver modules are about to be ported to MFC.
PD-ORIG\dll.cpp:#include "product.h"  // Special version just for printer driver. 
PD-ORIG\htmlexp.cpp:// New HTML export structure was integrated into printer driver.
PD-ORIG\htmlexp.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
PD-ORIG\htmlexp.cpp:// When no printer, leave page length in points.
PD-ORIG\htmlexp.cpp:// Also no longer require a printer
PD-ORIG\htmlexp.cpp:		// no printer, assume some defaults
PD-ORIG\htmlexp.cpp:		{ // compensate if the Windows printer orientation is landscape
PD-ORIG\htmlexp.cpp:				VTRES, ps->pDest.html.printerInchX);
PD-ORIG\htmlexp.cpp:				VTRES, ps->pDest.html.printerInchY);
PD-ORIG\htmlexp.cpp:		// get left margin in printer resolution units
PD-ORIG\htmlexp.cpp:		int leftMar = MulDiv(pi->leftmar, ps->pDest.html.printerInchX, 100);
PD-ORIG\htmlexp.cpp:		ps->pDest.html.unTop = (WORD)MulDiv(pO.y, VTRES, ps->pDest.html.printerInchY);
PD-ORIG\htmlexp.cpp:		// convert to printer resolution units
PD-ORIG\htmlexp.cpp:		ps->pDest.html.topMarg = MulDiv(ps->pDest.html.topMarg, ps->pDest.html.printerInchY, 100);
PD-ORIG\htmlexp.cpp:// return width of character based on printer font
PD-ORIG\htmlexp.cpp:		// may not have a printer, and therefore no printDC
PD-ORIG\htmlexp.cpp:// convert inches to printer resolution (e.g. dots)
PD-ORIG\htmlexp.cpp:		return ((DWORD)MulDiv(ps->pDest.html.printerInchX, inches, 100));
PD-ORIG\htmlexp.cpp:		// may not have a printer, and therefore no printDC
PD-ORIG\htmlexp.cpp:									VTRES, ps->pDest.html.printerInchY));
PD-ORIG\htmlexp.cpp:		// if no printer, assume default line height (like text export)
PD-ORIG\htmlexp.cpp:												MulDiv(lineAscent, VTRES, ps->pDest.html.printerInchY));
PD-ORIG\htmlexp.cpp:	return (MAKELONG(var, MulDiv(lineDescent, VTRES, ps->pDest.html.printerInchY)));
PD-ORIG\htmlexp.cpp:		DeleteDC(ps->pDest.html.printDC);	  // remove printer context
PD-ORIG\mem.cpp:// only by the printer driver code, since under low memory conditions, a message
PD-ORIG\mem.cpp:// the support to print the ole object records inside the printer driver.
PD-ORIG\mem.cpp:// Converted the printer driver to an MFC Extension DLL.
PD-ORIG\mem.cpp:// Printer driver modules are about to be ported to MFC.
PD-ORIG\mem.cpp:#include "product.h"  // Special version just for printer driver. 
PD-ORIG\pwprev.cpp:// Windows File Preview printer driver routines
PD-ORIG\pwprev.cpp:// the support to print the ole object records inside the printer driver.
PD-ORIG\pwprev.cpp:// the printer driver.
PD-ORIG\pwprev.cpp:// Converted the printer driver to an MFC Extension DLL.
PD-ORIG\pwprev.cpp:// Printer driver modules are about to be ported to MFC.
PD-ORIG\pwprev.cpp:#include "product.h"  // Special version just for printer driver. 
PD-ORIG\pxint.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
PD-ORIG\pxint.cpp:// zero and no printer.
PD-ORIG\pxint.cpp:// Changes to support export w/o printer
PD-ORIG\pxint.cpp:// Convert points to vertical printer resolution
PD-ORIG\pxint.cpp:	return (UINT)MulDiv( nPts, ps->pDest.wpd.printerInchY, POINTSIZE * 10 );
PD-ORIG\pxint.cpp:	// be zero if no printer is configured.
PD-ORIG\pxint.cpp:// Printer resolution -> 720ths
PD-ORIG\pxint.cpp:	return ((UINT)MulDiv( HZRES, x, ps->pDest.wpd.printerInchX ));
PD-ORIG\pxint.cpp:// Printer resolution -> 720ths
PD-ORIG\pxint.cpp:	return ((UINT)MulDiv( VTRES, y, ps->pDest.wpd.printerInchY ));
PD-ORIG\pxint.cpp:					{ // use DC - printer available
PD-ORIG\pxint.cpp:			{ // use DC - printer available
PD-ORIG\pxint.cpp:// Output a line of text to display or printer
PD-ORIG\pxint.cpp:						getWord( ps, &nValue );	// get width in printer dots
PD-ORIG\tblentry.cpp:// New HTML export structure was integrated into printer driver.
PD-ORIG\tblentry.cpp:	// The pFrame class was NULL when doing RI_PRINTER=H test.
EXPORTMG\CODEDLL\codedll.cpp:									  LPSTR lpszPrinterName,
EXPORTMG\DLG\rrxtab.cpp:				  LPSTR lpszPrinterName,
EXPORTMG\DLG\rrxtab.cpp:	strcpy (lpGlobalXTAB_Info->szPrinterName, lpszPrinterName);	// optional printer name
CFEVAL\fstr.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
WFIELD\wbitmap.cpp:	LPFNPWSETPALETTE lpfnSetPalette = (LPFNPWSETPALETTE)GetProcAddress(hPrinterDriver,MAKEINTRESOURCE(PWSETPALETTE));
WFIELD\wedtx.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
WFIELD\chart.cpp:#include "global.h"		// for hPrinterDriver
WFIELD\chart.cpp:	// load function pointers for printer driver
WFIELD\imglib.cpp:// printer DLL are lost when the DLL is freed and reloaded.
WFIELD\imglib.cpp:#include	"global.h"		// for hPrinterDriver, hImageLib
WFIELD\imglib.cpp:		// Send the printer driver the functions it needs.
WFIELD\imglib.cpp:	if ((lpfnImgFuncs = (LPFNIMGFUNCS)GetProcAddress(hPrinterDriver,SZ_PWIMGFUNCS)) == NULL)
WFIELD\edittext.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
SPEC\specopt.cpp:// and HTML value in the RI_PRINTER field.
SPEC\specmain.cpp:// Add parameter to printStats() to write to report spec file instead of printer
SPEC\specmain.cpp:	LPFNPWRECORDLINE lpfnRecordLine = (LPFNPWRECORDLINE)GetProcAddress(m_pDoc->hPrinterDriver,MAKEINTRESOURCE(PWRECORDLINE));
SPEC\specmain.cpp:	LPFNPWBOL lpfnBOL = (LPFNPWBOL)GetProcAddress(m_pDoc->hPrinterDriver,MAKEINTRESOURCE(PWBOL));
SPEC\specmain.cpp:	LPFNPWEOL lpfnEOL = (LPFNPWEOL)GetProcAddress(m_pDoc->hPrinterDriver,MAKEINTRESOURCE(PWEOL));
SPEC\specmain.cpp:	LPFNPWPAGEROOM lpfnPageRoom = (LPFNPWPAGEROOM)GetProcAddress(m_pDoc->hPrinterDriver,MAKEINTRESOURCE(PWPAGEROOM));
SPEC\specmain.cpp:	LPFNPWTOPMARGIN lpfnTopMargin = (LPFNPWTOPMARGIN)GetProcAddress(m_pDoc->hPrinterDriver,MAKEINTRESOURCE(PWTOPMARGIN));
SPEC\specmain.cpp:		LPFNPWTOPMARGIN lpfnTopMargin = (LPFNPWTOPMARGIN)GetProcAddress(m_pDoc->hPrinterDriver,MAKEINTRESOURCE(PWTOPMARGIN));
SPEC\specmain.cpp:		lpfnTopMargin = (LPFNPWTOPMARGIN)GetProcAddress(m_pDoc->hPrinterDriver,MAKEINTRESOURCE(PWTOPMARGIN));
SPEC\specquer.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
SPEC\specfld2.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
SPEC\specfld1.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
PRINT\rplib.cpp:	LPFNPWFONTHEIGHT lpfnFontHeight = (LPFNPWFONTHEIGHT)GetProcAddress(hPrinterDriver,MAKEINTRESOURCE(PWFONTHEIGHT));
PRINT\rppage.cpp:	LPFNPWPAGEROOM lpfnPageRoom = (LPFNPWPAGEROOM)GetProcAddress(hPrinterDriver,MAKEINTRESOURCE(PWPAGEROOM));
PRINT\rppage.cpp:			LPFNPWVERTICAL lpfnVertical = (LPFNPWVERTICAL)GetProcAddress(hPrinterDriver,MAKEINTRESOURCE(PWVERTICAL));
PRINT\rppage.cpp:		lpfnFF = (LPFNPWFF)GetProcAddress(hPrinterDriver,MAKEINTRESOURCE(PWFF));
PRINT\prec.cpp://  consistency of font appearance on display and printer.
PRINT\prec.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
PRINT\prec.cpp:// the support to print the ole object records inside the printer driver.
PRINT\prec.cpp:// Save both screen and printer rgb values for lines/boxes.
PRINT\prec.cpp:// horizontal screen resolution -> horizontal printer resolution
PRINT\prec.cpp:WORD CRrDoc::screenToPrinterX(WORD x)
PRINT\prec.cpp:	return ((WORD)MulDiv(PrinterInchX, x, theApp.InchX));
PRINT\prec.cpp:// vertical screen resolution -> vertical printer resolution
PRINT\prec.cpp:WORD CRrDoc::screenToPrinterY(WORD y)
PRINT\prec.cpp:	return ((WORD)MulDiv(PrinterInchY, y, theApp.InchY));
PRINT\prec.cpp:// internal vertical resolution (720ths) -> vertical printer resolution
PRINT\prec.cpp:WORD CRrDoc::vertToPrinter(WORD y)
PRINT\prec.cpp:	return ((WORD)MulDiv(y, PrinterInchY, VTRES));
PRINT\prec.cpp:	LPFNPWRECORDCHART lpfnRecordChart = (LPFNPWRECORDCHART)GetProcAddress(hPrinterDriver, MAKEINTRESOURCE(PWRECORDCHART));
PRINT\prec.cpp:			y = vertToPrinter(endY + ydelta);
PRINT\prec.cpp:			y = vertToPrinter(endY - ydelta);
PRINT\prec.cpp:	int y = vertToPrinter(endY - ydelta);
PRINT\prec.cpp:	LPFNPWRECORDIMAGE lpfnRecordImage = (LPFNPWRECORDIMAGE)GetProcAddress(hPrinterDriver, MAKEINTRESOURCE(PWRECORDIMAGE));
PRINT\prec.cpp:			y = vertToPrinter(endY + ydelta);
PRINT\prec.cpp:			y = vertToPrinter(endY - ydelta);
PRINT\prec.cpp:	LPFNPWRECORDOLEOBJECT lpfnRecordOleObject = (LPFNPWRECORDOLEOBJECT)GetProcAddress(hPrinterDriver, MAKEINTRESOURCE(PWRECORDOLEOBJECT));
PRINT\prec.cpp:			y = vertToPrinter(endY + ydelta);
PRINT\prec.cpp:			y = vertToPrinter(endY - ydelta);
PRINT\prec.cpp:	unsigned int printhite = vertToPrinter(lineHite);	// printer units
PRINT\prec.cpp:	unsigned int printyb = vertToPrinter(vertyb);
PRINT\prec.cpp:	unsigned int printyt = justscale ? vertToPrinter(vertyt) : printyb - printhite;
PRINT\prec.cpp:	LPFNPWRECORDBOX lpfnRecordBox =	(LPFNPWRECORDBOX)GetProcAddress(hPrinterDriver,
PRINT\prec.cpp:	LPFNPWRECORDLINESEG lpfnRecordLineSeg =	(LPFNPWRECORDLINESEG)GetProcAddress(hPrinterDriver,
PRINT\prec.cpp:						screenToPrinterX((WORD)(pixxl+((SnkCurrCol-1)*across_pix)));
PRINT\prec.cpp:						screenToPrinterX((WORD)(pixxr+((SnkCurrCol-1)*across_pix)));
PRINT\prec.cpp:				pBox.printXL = screenToPrinterX((WORD)(pixxl + (i * across_pix)));
PRINT\prec.cpp:				pBox.printXR = screenToPrinterX((WORD)(pixxr+(i * across_pix)));
PRINT\prec.cpp:			pBox.thickness = screenToPrinterX(lpbox->thickness);
PRINT\prec.cpp:			//	mjs 8/5/93 Transparent is clear in Preview, white at printer.
PRINT\prec.cpp:			// mjs 9/12/94  Save both printer and screen colors.
PRINT\prec.cpp:			//	mjs 8/5/93 Transparent is clear in Preview, white at printer.
PRINT\prec.cpp:	LPFNPWVERTLOC lpfnVertLoc = (LPFNPWVERTLOC)GetProcAddress(hPrinterDriver,
PRINT\prec.cpp:							lpbox->startY = y - ydelta;	// save printer loc
PRINT\prec.cpp:	LPFNPWENDBAND lpfnEndBand = (LPFNPWENDBAND)GetProcAddress(hPrinterDriver, MAKEINTRESOURCE(PWENDBAND));
PRINT\prec.cpp:	LPFNPWVERTICAL lpfnVertical = (LPFNPWVERTICAL)GetProcAddress(hPrinterDriver, MAKEINTRESOURCE(PWVERTICAL));
PRINT\prec.cpp:	LPFNPWVERTLOC lpfnVertLoc = (LPFNPWVERTLOC)GetProcAddress(hPrinterDriver, MAKEINTRESOURCE(PWVERTLOC));
PRINT\vputil.cpp:	LPFNPWVERTICAL lpfnVertical = (LPFNPWVERTICAL)GetProcAddress(hPrinterDriver,MAKEINTRESOURCE(PWVERTICAL));
PRINT\vputil.cpp:	LPFNPWPAGEROOM lpfnPageRoom = (LPFNPWPAGEROOM)GetProcAddress(hPrinterDriver,MAKEINTRESOURCE(PWPAGEROOM));
PRINT\vputil.cpp:	LPFNPWFINDATT lpfnFindAtt = (LPFNPWFINDATT)GetProcAddress(hPrinterDriver, MAKEINTRESOURCE(PWFINDATT));
PRINT\vputil.cpp:	LPFNPWRESET lpfnReset = (LPFNPWRESET)GetProcAddress(hPrinterDriver,MAKEINTRESOURCE(PWRESET));
PRINT\rprint.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
PRINT\rprint.cpp:	LPFNPWFONTHEIGHT lpfnFontHeight = (LPFNPWFONTHEIGHT)GetProcAddress(hPrinterDriver,MAKEINTRESOURCE(PWFONTHEIGHT));
PRINT\rprint.cpp:	LPFNPWLINEHEIGHT lpfnLineHeight = (LPFNPWLINEHEIGHT)GetProcAddress(hPrinterDriver,MAKEINTRESOURCE(PWLINEHEIGHT));
PRINT\pline.cpp:// the support to print the ole object records inside the printer driver.
PRINT\pline.cpp:			if (lpfnLineHeight = (LPFNPWLINEHEIGHT)GetProcAddress(hPrinterDriver,MAKEINTRESOURCE(PWLINEHEIGHT)))
PRINT\pline.cpp:	LPFNPWRECORDLINE lpfnRecordLine = (LPFNPWRECORDLINE)GetProcAddress(hPrinterDriver,MAKEINTRESOURCE(PWRECORDLINE));
PRINT\pline.cpp:	LPFNPWBOL lpfnBOL = (LPFNPWBOL)GetProcAddress(hPrinterDriver, MAKEINTRESOURCE(PWBOL));
PRINT\pline.cpp:	LPFNPWEOL lpfnEOL = (LPFNPWEOL)GetProcAddress(hPrinterDriver, MAKEINTRESOURCE(PWEOL));
PRINT\pline.cpp:	LPFNPWVERTLOC lpfnVertLoc = (LPFNPWVERTLOC)GetProcAddress(hPrinterDriver, MAKEINTRESOURCE(PWVERTLOC));
PRINT\pline.cpp:	LPFNPWRECORDLINE lpfnRecordLine = (LPFNPWRECORDLINE)GetProcAddress(hPrinterDriver,MAKEINTRESOURCE(PWRECORDLINE));
PRINT\pline.cpp:	LPFNPWBOL lpfnBOL = (LPFNPWBOL)GetProcAddress(hPrinterDriver, MAKEINTRESOURCE(PWBOL));
PRINT\pline.cpp:	LPFNPWEOL lpfnEOL = (LPFNPWEOL)GetProcAddress(hPrinterDriver, MAKEINTRESOURCE(PWEOL));
PRINT\pline.cpp:	LPFNPWLINEHEIGHT lpfnLineHeight = (LPFNPWLINEHEIGHT)GetProcAddress(hPrinterDriver, MAKEINTRESOURCE(PWLINEHEIGHT));
PRINT\pline.cpp:	LPFNPWVERTICAL lpfnVertical = (LPFNPWVERTICAL)GetProcAddress(hPrinterDriver, MAKEINTRESOURCE(PWVERTICAL));
PRINT\rpwrap.cpp://  most export/printer DLLs to use a new internal SpaceDot function instead
PRINT\rpwrap.cpp:// imbed the proper printer driver information...
PRINT\rpwrap.cpp:	LPFNPWDOTWIDTH lpfnDotWidth = (LPFNPWDOTWIDTH)GetProcAddress(hPrinterDriver,MAKEINTRESOURCE(PWDOTWIDTH));
PRINT\rpwrap.cpp:	LPFNPWCHARWIDTH lpfnCharWidth = (LPFNPWCHARWIDTH)GetProcAddress(hPrinterDriver,MAKEINTRESOURCE(PWCHARWIDTH));
PRINT\rpprep.cpp:	if (lpfnReset = (LPFNPWRESET)GetProcAddress(m_pExport->m_pDoc->hPrinterDriver,MAKEINTRESOURCE(PWRESET)))
PRINT\rphf.cpp:	LPFNPWVERTICAL lpfnVertical = (LPFNPWVERTICAL)GetProcAddress(hPrinterDriver,MAKEINTRESOURCE(PWVERTICAL));
PRINT\rphf.cpp:	LPFNPWVERTICAL lpfnVertical = (LPFNPWVERTICAL)GetProcAddress(hPrinterDriver,MAKEINTRESOURCE(PWVERTICAL));
PRINT\rphf.cpp:	LPFNPWTOPMARGIN lpfnTopMargin = (LPFNPWTOPMARGIN)GetProcAddress(hPrinterDriver,MAKEINTRESOURCE(PWTOPMARGIN));
PRINT\rphf.cpp:	LPFNPWVERTICAL lpfnVertical = (LPFNPWVERTICAL)GetProcAddress(hPrinterDriver,MAKEINTRESOURCE(PWVERTICAL));
PRINT\rphf.cpp:	LPFNPWTOPMARGIN lpfnTopMargin = (LPFNPWTOPMARGIN)GetProcAddress(hPrinterDriver,MAKEINTRESOURCE(PWTOPMARGIN));
PRINT\rphf.cpp:	LPFNPWVERTICAL lpfnVertical = (LPFNPWVERTICAL)GetProcAddress(hPrinterDriver,MAKEINTRESOURCE(PWVERTICAL));
PRINT\rphf.cpp:	LPFNPWTOPMARGIN lpfnTopMargin = (LPFNPWTOPMARGIN)GetProcAddress(hPrinterDriver,MAKEINTRESOURCE(PWTOPMARGIN));
PRINT\rphf.cpp:	LPFNPWTOPMARGIN lpfnTopMargin = (LPFNPWTOPMARGIN)GetProcAddress(hPrinterDriver,MAKEINTRESOURCE(PWTOPMARGIN));
